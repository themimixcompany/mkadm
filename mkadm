#!/usr/bin/env bash

set -eu
set -o pipefail

readonly SELF="$(basename ${BASH_SOURCE[0]})"
readonly SELF_DIR="$(cd $(dirname $(readlink -f ${BASH_SOURCE[0]})) > /dev/null 2>&1 && pwd)"
readonly OS=$(uname)
readonly VERSION=1.1.3

readonly OPT_BASE_NAME=${SELF}

OPT_HELP=
OPT_DEBUG=
OPT_VERBOSE=

OPT_SLEEP=15
OPT_RESOURCES_DIR=${SELF_DIR}/resources

OPT_WIKI_NAME=
OPT_WIKI_DOMAIN=
OPT_WIKI_RESOURCES=/_assets/svg

OPT_COMPANY_NAME=
OPT_COMPANY_DOMAIN=

OPT_DEFAULT_PACKAGE_VERSION="1.0.0"
OPT_PACKAGE_VERSION=

OPT_BASE_COMMIT="2.5.159"

OPT_ENABLE_WIKI_SSL=false
OPT_ENABLE_DB_SSL=false
OPT_PASSWORD_FILE=

OPT_MAKE_TARBALL=
OPT_PGADM=
OPT_INSTALL_DIRECTORY=

OPT_SSH_KEY=
OPT_DROPLET_USER=root
OPT_DROPLET_NAME=
OPT_DROPLET_ADDRESS=

OPT_DATABASE_NAME=defaultdb
OPT_DATABASE_USER=doadmin
OPT_DATABASE_INIT=

OPT_FIREWALL_NAME=
OPT_FIREWALL_ADDRESSES=
OPT_FIREWALL_PORTS="22,80,443"

OPT_WORK_DIRECTORY=

function error () {
  if [[ "${OS}" == "Darwin" ]]; then
    echo "error: ${@}" >&2
  else
    echo -e "\e[0;31m\e[1merror: \e[0;0m${@}" >&2
  fi

  exit 1
}

function warn () {
  if [[ "${OS}" == "Darwin" ]]; then
    echo "warning: ${@}" >&2
  else
    echo -e "\e[0;33mwarning: \e[0;0m${@}" >&2
  fi
}

function debug () {
  if [[ -n "${OPT_DEBUG}" ]]; then
    echo '**'
    echo \${@}: ${@}
    echo \$OPT_DEBUG: "${OPT_DEBUG}"
  fi
}

function parse_arguments () {
  debug ${FUNCNAME[0]} "$@"

  local opts=$(getopt -n "${SELF}" --options hvw:d:r:c:o:V:sStp:i:k:D:B:U:I:F:A:P: --longoptions help,debug,verbose,wiki-name:,wiki-domain:,wiki-resources:,company-name:,company-domain:,package-version:,enable-wiki-ssl,enable-db-ssl,make-tarball,pgadm:,install-directory:,ssh-key:,droplet-name:,database-name:,database-user:,database-init:,firewall-name:,firewall-addresses:,firewall-ports: -- "$@")

  if [[ $? != 0 ]]; then
    error "Failed to parse arguments. Exiting."
  fi

  eval set -- "${opts}"

  while true; do
    case "$1" in
      (-h|--help) OPT_HELP=true; shift ;;
      (--debug) OPT_DEBUG=true; shift ;;
      (-v|--verbose) OPT_VERBOSE=true; shift ;;
      (-w|--wiki-name) OPT_WIKI_NAME=$2; shift 2 ;;
      (-d|--wiki-domain) OPT_WIKI_DOMAIN=$2; shift 2 ;;
      (-r|--wiki-resources) OPT_WIKI_RESOURCES=$2; shift 2 ;;
      (-c|--company-name) OPT_COMPANY_NAME=$2; shift 2 ;;
      (-o|--company-domain) OPT_COMPANY_DOMAIN=$2; shift 2 ;;
      (-V|--package-version) OPT_PACKAGE_VERSION=$2; shift 2 ;;
      (-s|--enable-wiki-ssl) OPT_ENABLE_WIKI_SSL=true; shift ;;
      (-S|--enable-db-ssl) OPT_ENABLE_DB_SSL=true; shift ;;
      (-t|--make-tarball) OPT_MAKE_TARBALL=true; shift ;;
      (-p|--pgadm) OPT_PGADM=$2; shift 2 ;;
      (-i|--install-directory) OPT_MAKE_TARBALL=true; OPT_INSTALL_DIRECTORY=$2; shift 2 ;;
      (-k|--ssh-key) OPT_SSH_KEY=$2; shift 2 ;;
      (-D|--droplet-name) OPT_DROPLET_NAME=$2; shift 2 ;;
      (-B|--database-name) OPT_DATABASE_NAME=$2; shift 2 ;;
      (-U|--database-user) OPT_DATABASE_USER=$2; shift 2 ;;
      (-I|--database-init) OPT_DATABASE_INIT=$2; shift 2 ;;
      (-F|--firewall-name) OPT_FIREWALL_NAME=$2; shift 2 ;;
      (-A|--firewall-addresses) OPT_FIREWALL_ADDRESSES=$2; shift 2 ;;
      (-P|--firewall-ports) OPT_FIREWALL_PORTS=$2; shift 2 ;;
      (--) shift; break ;;
      (*) break ;;
    esac
  done

  OPT_WORK_DIRECTORY="$(readlink -f ${@: -1})"
}

function process_arguments () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_HELP}" || "${#}" -lt 1 ]]; then
    display_usage
  elif [[ ! "$(basename ${OPT_WORK_DIRECTORY})" == "miki" ]]; then
    display_usage
  elif [[ -z "${OPT_WIKI_NAME}" || -z "${OPT_WIKI_DOMAIN}" || -z "${OPT_WIKI_RESOURCES}" || -z "${OPT_COMPANY_NAME}" || -z "${OPT_COMPANY_DOMAIN}" ]]; then
    display_usage
  elif [[ -n "${OPT_INSTALL_DIRECTORY}" && -z "${OPT_SSH_KEY}" ]]; then
    display_usage
  else
    return 0
  fi
}

function display_usage () {
  debug ${FUNCNAME[0]} "$@"

  cat << EOF
${SELF} v${VERSION} [OPTIONS]...

OPTIONS:
  -h, --help               Show this help
  -d, --debug              Enable debugging mode
  -v, --verbose            Enable verbose output
  -w, --wiki-name          Set wiki name
  -d, --wiki-domain        Set wiki domain
  -r, --wiki-resources     Set location of wiki resources
  -c, --company-name       Set company name
  -o, --company-domain     Set company domain
  -V, --package-version    Set version in package.json
  -s, --enable-wiki-ssl    Enable wiki SSL (default: ${OPT_ENABLE_WIKI_SSL})
  -S, --enable-db-ssl      Enable database SSL (default: ${OPT_ENABLE_DB_SSL})
  -t, --make-tarball       Create a tarball of the input
  -p, --pgadm              Specify the pgadmn program to upload
  -i, --install-directory  Set the installation directory of Miki
  -k, --ssh-key            Set the allowed SSH key for the droplet
  -D, --droplet-name       Set the name of droplet to create
  -B, --database-name      Set the name of the database
  -U, --database-user      Set the name of the database user
  -I, --database-init      Initialize the database with a dump
  -F, --firewall-name      Set the name of firewall for this droplet
  -A, --firewall-addresses A comma-separated list of IP addresses to allow on the droplet
  -P, --firewall-ports     A comma-separated list of allowed ports on the droplet
EOF
  exit 0
}

function initialize () {
  debug ${FUNCNAME[0]} "$@"

  pushd "${OPT_WORK_DIRECTORY}" &> /dev/null

  if [[ -f "package.json" && "$(jq -r '.name' package.json)" == "wiki" ]]; then
    return 0
  else
    error "!"
  fi
}

function reset_repository () {
  debug ${FUNCNAME[0]} "$@"

  git reset --hard "${OPT_BASE_COMMIT}"
}

function delete_files () {
  debug ${FUNCNAME[0]} "$@"

  rm -f README.md SECURITY.md
  rm -rf .github

  rm -f assets/favicon.ico
  rm -rf assets/favicons
  rm -f assets/svg/logo-wikijs.svg
  rm -f assets/svg/logo-wikijs-full.svg

  rm -f assets/js/admin.js

  rm -rf assets/img/splash

  rm -rf db
  rm -rf data
}

function create_readme () {
  debug ${FUNCNAME[0]} "$@"

  cat << EOF > README.md
# miki
EOF
}

function create_local_config_yml () {
  debug ${FUNCNAME[0]} "$@"

  cat << EOF > config.yml
port: 3000

db:
  type: sqlite
  storage: db/db.sqlite

ssl:
  enabled: false

pool:
  # min: 2
  # max: 10

bindIP: 0.0.0.0

logLevel: info

offline: false

ha: false

dataPath: ./data
EOF
}

function find_id () {
  debug ${FUNCNAME[0]} "$@"

  local path=$1
  local regex=$2

  find ${path} -name "${regex}" | awk -F \. '{print $2}'
}

function copy_vue_files () {
  debug ${FUNCNAME[0]} "$@"

  rsync -a "${OPT_RESOURCES_DIR}/client" .
}

function update_files () {
  debug ${FUNCNAME[0]} "$@"

  declare -A SUBSTITUTIONS=(
    ['wikijs-butterfly.svg']="${OPT_COMPANY_NAME}.svg"

    ['wiki\.js']="${OPT_WIKI_NAME}"
    ['wiki-js']="${OPT_WIKI_NAME}"
    ['wikijs']="${OPT_WIKI_NAME}"
    ['Wiki\.js']="${OPT_WIKI_NAME^}"
    ['WIKI\.js']="${OPT_WIKI_NAME^}"

    ['wiki\.js\.org']="${OPT_WIKI_DOMAIN}"
    ['wiki\.yourdomain\.com']="${OPT_WIKI_DOMAIN}"

    ['https://static\.requarks\.io/logo']="${OPT_WIKI_RESOURCES}"

    ['https://github\.com/Requarks/wiki']="https://github.com/themimixcompany/miki"

    #['requarks\.io']="${OPT_COMPANY_DOMAIN}"
    #['requarks']="${OPT_COMPANY_NAME}"
    #['Requarks']="${OPT_COMPANY_NAME^}"
  )

  for i in "${!SUBSTITUTIONS[@]}"; do
    for file in $(rg -l "$i"); do
      sed -i -e "s|${i}|${SUBSTITUTIONS[$i]}|g" "$file"
    done
  done
}

function update_package_json () {
  debug ${FUNCNAME[0]} "$@"

  local temp=$(mktemp)
  local version=${OPT_PACKAGE_VERSION:-${OPT_DEFAULT_PACKAGE_VERSION}}

  cat package.json | jq ".version = \"${version}\""  | jq '.dev = false' > "${temp}"
  mv -f ${temp} package.json
}

function yarn_build () {
  debug ${FUNCNAME[0]} "$@"

  echo "================================================================================"
  echo " Compiling sources ..."
  echo "================================================================================"

  yarn build
}

function install_assets () {
  debug ${FUNCNAME[0]} "$@"

  rsync -a ${OPT_RESOURCES_DIR}/assets/favicon.ico assets
  rsync -a ${OPT_RESOURCES_DIR}/assets/favicons assets
  rsync -a ${OPT_RESOURCES_DIR}/assets/svg assets
  rsync -a ${OPT_RESOURCES_DIR}/assets/img/splash assets/img
}

function create_db_directory () {
  debug ${FUNCNAME[0]} "$@"

  mkdir -p db
}

function create_password () {
  debug ${FUNCNAME[0]} "$@"

  < /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c${1:-32}
}

function create_password_file () {
  debug ${FUNCNAME[0]} "$@"

  OPT_PASSWORD_FILE=$(mktemp)

  echo $(create_password) > "${OPT_PASSWORD_FILE}"
}

function create_remote_config_yml () {
  debug ${FUNCNAME[0]} "$@"

  cat << EOF > config.yml
#port: 3000

db:
  type: postgres
  host: localhost
  port: 5432
  user: ${OPT_DATABASE_USER}
  pass: $(cat ${OPT_PASSWORD_FILE})
  db: ${OPT_DATABASE_NAME}
  ssl: ${OPT_ENABLE_DB_SSL}
  sslOptions:
    auto: true
    ca: ./keys/ca.crt
    cert: ./keys/cert.pem
    key: ./keys/key.pem

ssl:
  enabled: ${OPT_ENABLE_WIKI_SSL}
  port: 443
  provider: letsencrypt
  domain: ${OPT_WIKI_DOMAIN}
  subscriberEmail: rom@mimix.io

pool:
  # min: 2
  # max: 10

bindIP: 0.0.0.0

logLevel: info

offline: false

ha: false

dataPath: ./data
EOF
}

function delete_password_file () {
  debug ${FUNCNAME[0]} "$@"

  rm -f "${OPT_PASSWORD_FILE}"
}

function create_init_sql () {
  debug ${FUNCNAME[0]} "$@"

  mkdir -p sql
  cat << EOF > sql/init.sql
CREATE database ${OPT_DATABASE_NAME};
CREATE user ${OPT_DATABASE_USER} password '$(cat ${OPT_PASSWORD_FILE})';
GRANT ALL PRIVILEGES ON DATABASE ${OPT_DATABASE_NAME} TO ${OPT_DATABASE_USER};
EOF
}

function copy_bin () {
  debug ${FUNCNAME[0]} "$@"

  rm -rf bin
  rsync -aL "${SELF_DIR}/bin" .
}

function create_tarball () {
  debug ${FUNCNAME[0]} "$@"

  local file=$(basename ${OPT_WORK_DIRECTORY}).tar.gz

  popd &> /dev/null

  if [[ -n "${OPT_MAKE_TARBALL}" ]]; then
    tar -C "$(dirname ${OPT_WORK_DIRECTORY})" \
        -czf "${file}" --exclude ".git" \
        "$(basename ${OPT_WORK_DIRECTORY})"
  fi
}

function create_droplet () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_INSTALL_DIRECTORY}" && -n "${OPT_DROPLET_NAME}" ]]; then
    OPT_DROPLET_ADDRESS=$(doadm -DCN "${OPT_DROPLET_NAME}" -K "${OPT_SSH_KEY}" )
    echo "${OPT_DROPLET_ADDRESS}"
  fi
}

function droplet_ok () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_DROPLET_NAME}" && -n "${OPT_DROPLET_ADDRESS}" ]]; then
    return 0
  else
    return 1
  fi
}

function upload_tarball () {
  debug ${FUNCNAME[0]} "$@"

  local file="$(basename ${OPT_WORK_DIRECTORY}).tar.gz"

  sleep "${OPT_SLEEP}"

  if [[ -n "${OPT_INSTALL_DIRECTORY}" ]] && droplet_ok && \
     [[ -f "${file}" && -n "${OPT_DROPLET_USER}" ]]; then
    scp -o StrictHostKeyChecking=no -o LogLevel=ERROR \
        "${file}" \
        "${OPT_DROPLET_USER}@${OPT_DROPLET_ADDRESS}:"
  fi
}

function delete_tarball () {
  debug ${FUNCNAME[0]} "$@"

  local directory="$(dirname ${OPT_WORK_DIRECTORY})"
  local file="$(basename ${OPT_WORK_DIRECTORY}).tar.gz"

  rm -f "${directory}/${file}"
}

function upload_database_init () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_DATABASE_INIT}" ]]; then
    scp -o StrictHostKeyChecking=no -o LogLevel=ERROR \
        "${OPT_DATABASE_INIT}" "${OPT_DROPLET_USER}@${OPT_DROPLET_ADDRESS}:/tmp"
  fi
}

function upload_pgadm () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_INSTALL_DIRECTORY}" ]] && droplet_ok; then
    scp -o StrictHostKeyChecking=no -o LogLevel=ERROR \
        "${OPT_PGADM}" "${OPT_DROPLET_USER}@${OPT_DROPLET_ADDRESS}:/usr/local/bin"
  fi
}

function install_miki () {
  debug ${FUNCNAME[0]} "$@"

  local file="$(basename ${OPT_WORK_DIRECTORY}).tar.gz"

  if [[ -n "${OPT_INSTALL_DIRECTORY}" ]] && droplet_ok; then
    ssh -o StrictHostKeyChecking=no -o LogLevel=ERROR \
        "${OPT_DROPLET_USER}@${OPT_DROPLET_ADDRESS}" \
        "tar -C /var -xf ${file}; \
         bash ${OPT_INSTALL_DIRECTORY}/bin/install -i ${OPT_INSTALL_DIRECTORY} -I /tmp/${OPT_DATABASE_INIT}"
  fi

  return 0
}

function create_firewall () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_FIREWALL_NAME}" ]]; then
    doadm -FCN "${OPT_FIREWALL_NAME}" -n "${OPT_DROPLET_NAME}" \
          -a "${OPT_FIREWALL_ADDRESSES}" -p "${OPT_FIREWALL_PORTS}"
  fi
}

function display_address () {
  debug ${FUNCNAME[0]} "$@"

  echo -e "\n"
  echo "================================================================================"
  echo " Your new Miki instance is now available at http://${OPT_DROPLET_ADDRESS}."
  echo "================================================================================"
  echo -n "${OPT_DROPLET_ADDRESS}" | xsel -b
}

function local_install () {
  debug ${FUNCNAME[0]} "$@"

  initialize
  reset_repository
  delete_files
  create_readme
  create_local_config_yml

  copy_vue_files
  update_files
  update_package_json
  yarn_build

  install_assets
  create_db_directory
}

function remote_install () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_INSTALL_DIRECTORY}" && -n "${OPT_SSH_KEY}" && \
        -n "${OPT_DROPLET_NAME}" && \
        -n "${OPT_DATABASE_NAME}" && -n "${OPT_DATABASE_USER}" ]]; then
    create_password_file
    create_remote_config_yml
    create_init_sql
    delete_password_file

    copy_bin
    create_tarball
    create_droplet
    upload_tarball
    delete_tarball

    upload_database_init
    upload_pgadm
    install_miki
    create_firewall

    display_address
  fi
}

function main () {
  debug ${FUNCNAME[0]} "$@"

  parse_arguments "$@"
  process_arguments "$@"

  local_install
  remote_install
}

main "$@"
