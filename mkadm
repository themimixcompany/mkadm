#!/usr/bin/env bash

set -euo pipefail

readonly SELF="$(basename ${BASH_SOURCE[0]})"
readonly SELF_DIR="$(cd $(dirname $(readlink -f ${BASH_SOURCE[0]})) > /dev/null 2>&1 && pwd)"
readonly OS="$(uname)"
readonly VERSION="2.12.0"

OPT_HELP=
OPT_DEBUG=
OPT_VERBOSE=
OPT_VERSION=

readonly VAL_BASE_NAME="miki"
readonly VAL_WWW_NAME="www"
readonly VAL_FW_NAME="fw"
readonly VAL_SLEEP="60"
readonly VAL_RANDOM="$(od -t uI -N 4 /dev/urandom | awk '{print $2}' | sed 2d)"
readonly VAL_BASE_COMMIT="2.5.159"
readonly VAL_DEFAULT_PACKAGE_VERSION="1.0.0"
readonly VAL_MIKI_DOMAIN="${VAL_BASE_NAME}.mimix.io"
readonly VAL_RESOURCES_DIR="${SELF_DIR}/resources"
readonly VAL_REMOTE_BIN="/usr/local/bin"
readonly VAL_REMOTE_TMP="/tmp"
readonly VAL_MIKI_REPOSITORY="https://github.com/themimixcompany/wiki"
readonly VAL_MIKI_LOCALES_REPOSITORY="https://github.com/themimixcompany/wiki-localization"
readonly VAL_HOOK_URL="http://hook"
readonly VAL_CHARGIFY_USERNAME="jm6xz1asP3UlyizRoeC7UbeXsJ90x0wbY2bwOOg34"
readonly VAL_SNAPSHOT_ID="74983549"
readonly VAL_SEED_FILE="$HOME/miki-seed.tar"
readonly VAL_JS_FILTER="${SELF_DIR}/filter.js"

readonly VAL_MIKI_DESKTOP="${SELF_DIR}/dat/miki-desktop.tar.xz"
readonly VAL_MODULES_LINUX_MIKI="${SELF_DIR}/dat/node_modules-linux-miki.tar.xz"
readonly VAL_MODULES_LINUX_MIKI_DESKTOP="${SELF_DIR}/dat/node_modules-linux-miki-desktop.tar.xz"
readonly VAL_MODULES_WINDOWS_MIKI="${SELF_DIR}/dat/node_modules-windows-miki.tar.xz"
readonly VAL_MODULES_WINDOWS_MIKI_DESKTOP="${SELF_DIR}/dat/node_modules-windows-miki-desktop.tar.xz"
readonly VAL_MODULES_MACOS_MIKI="${SELF_DIR}/dat/node_modules-macos-miki.tar.xz"
readonly VAL_MODULES_MACOS_MIKI_DESKTOP="${SELF_DIR}/dat/node_modules-macos-miki-desktop.tar.xz"

readonly VAL_SPACES_EXPIRY="3"

VAL_DOMAIN_NAME=
VAL_DROPLET_NAME=
VAL_FIREWALL_NAME=
VAL_PASSWORD_FILE=

VAL_ADMIN_PASSWORD=
VAL_ADMIN_PASSWORD_HASH=
VAL_ADMIN_SQL_LOCAL_FILE=
VAL_ADMIN_SQL_REMOTE_FILE=

OPT_CREATE_SUPPORT_ACCOUNT=
VAL_SUPPORT_PASSWORD=
VAL_SUPPORT_PASSWORD_HASH=
VAL_SUPPORT_SQL_LOCAL_FILE=
VAL_SUPPORT_SQL_REMOTE_FILE=

OPT_NAME=
OPT_EMAIL=
OPT_MIKI_DIRECTORY=
OPT_WIKI_NAME="${VAL_BASE_NAME}"
OPT_WIKI_DOMAIN=
OPT_WIKI_RESOURCES="/_assets/svg"
OPT_COMPANY_NAME="${VAL_BASE_NAME}"
OPT_COMPANY_DOMAIN="mimix.io"
OPT_ENABLE_WIKI_SSL="true"
OPT_ENABLE_DB_SSL="false"
OPT_PACKAGE_VERSION=
OPT_INSTALL_PATH="/var/miki"
OPT_PGADM_PATH="$(which pgadm)"
OPT_PGSQL_PATH="$(which pgsql)"
OPT_INSTALL_REMOTELY=
OPT_REMOVE_SELF_SSH_KEY=
OPT_SSH_KEYS=
OPT_DROPLET_USER="root"
OPT_DROPLET_NAME=
OPT_DROPLET_ADDRESS=
OPT_DATABASE_NAME="defaultdb"
OPT_DATABASE_USER="doadmin"
OPT_DATABASE_INIT="${SELF_DIR}/dat/miki-core.postgres.xz"
OPT_FIREWALL_NAME=
OPT_FIREWALL_ADDRESSES=
OPT_FIREWALL_PORTS="22,80,443"
OPT_CREATE_FIREWALL=
OPT_SEND_FILTER=
OPT_YAML_FILTER=
OPT_QUERY_FILTER=
OPT_CONFIG_ENABLE_SSL=
OPT_CONFIG_DISABLE_SSL=
OPT_CONFIG_DOMAIN_NAME=
OPT_SSH=
OPT_COMMAND=
OPT_SQL=
OPT_SQL_FILE=
OPT_EXPUNGE_INSTANCE=
OPT_FORCE_EXPUNGE_INSTANCE=
OPT_LIST_INSTANCES=
OPT_RESET_ADMIN_PASSWORD=
OPT_POWER_ON=
OPT_POWER_OFF=
OPT_RESTORE_DATABASE=
OPT_DUMP_DATABASE=
OPT_RESTART_MIKI=
OPT_RESTART_MACHINE=
OPT_ORIGIN_PATH=
OPT_DESTINATION_PATH=
OPT_CHECK_NAME=
OPT_GARBAGE_COLLECT=
OPT_NEW_NAME=
OPT_SUBSCRIPTION_ID="01234567"
OPT_DELETE_AUTH0_USER=
OPT_REPLACE_INSTANCE=
OPT_REPLACE_TARBALL_BASE="miki-base.tar.xz"
OPT_REPLACE_TARBALL="${SELF_DIR}/dat/${OPT_REPLACE_TARBALL_BASE}"
OPT_SNAPSHOT_INSTANCE=
OPT_SNAPSHOT_TARBALL=
OPT_USE_CACHE=
OPT_DOMAIN="streamsharing.io"
OPT_SUBDOMAIN=
OPT_DESKTOP=
OPT_SQLITE_DATABASE_INIT="${SELF_DIR}/dat/miki-core.sqlite.xz"
OPT_SPACES_BASE="fra1.digitaloceanspaces.com"
OPT_SPACES_SUBDOMAIN="mimix"
OPT_SPACES_URL="http://${OPT_SPACES_SUBDOMAIN}.${OPT_SPACES_BASE}"
OPT_MIKI_DESKTOP_DIRECTORY=
OPT_SPACES_BUCKET="s3://mimix"
OPT_DESKTOP_URL=

function error () {
  if [[ "${OS}" == "Darwin" ]]; then
    echo "ERROR: ${@}" >&2
  else
    echo -e "\e[0;31m\e[1mERROR: \e[0;0m${@}" >&2
  fi

  exit 1
}

function warn () {
  if [[ "${OS}" == "Darwin" ]]; then
    echo "WARNING: ${@}" >&2
  else
    echo -e "\e[0;33mWARNING: \e[0;0m${@}" >&2
  fi
}

function debug () {
  if [[ -n "${OPT_DEBUG}" ]]; then
    echo -n "** "
    echo "\${PWD}: ${PWD}"
    echo "\${@}: ${@}"
  fi
}

function push () {
  debug "${FUNCNAME[0]}" "$@"

  pushd "${1}" &> /dev/null
}

function pop () {
  debug "${FUNCNAME[0]}" "$@"

  popd &> /dev/null
}

function run_ssh () {
  debug "${FUNCNAME[0]}" "$@"

  ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o LogLevel=ERROR "$@"
}

function run_scp () {
  debug "${FUNCNAME[0]}" "$@"

  scp -c aes256-gcm@openssh.com -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o LogLevel=ERROR "$@"
}

function run_rsync () {
  debug "${FUNCNAME[0]}" "$@"

  rsync -avzL --delete \
        -e "ssh -T -c aes256-gcm@openssh.com -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o LogLevel=ERROR" \
        "$@"
}

function parse_arguments () {
  debug "${FUNCNAME[0]}" "$@"

  local opts=$(getopt -n "${SELF}" --options n:e:p:iKk:A:P:fH:Y:y:lsc:SF:xXrtCGN:I:RTUD: --longoptions help,debug,verbose,version,name:,wiki-name:,wiki-domain:,wiki-resources:,company-name:,company-domain:,enable-wiki-ssl,enable-db-ssl,install-path:,pgadm-path:,package-version:,install-remotely,remove-self-ssh-key,ssh-keys:,droplet-name:,database-name:,database-user:,database-init:,no-database-init,firewall-name:,add-self-address,firewall-addresses:,firewall-ports:,create-firewall,host:,send-filter:,query-filter:,config-enable-ssl,config-disable-ssl,config-domain-name:,list-instances,list,command:,ssh,sql,sql-file:,expunge-instance,force-expunge-instance,reset-admin-password,create-support-account,power-on,power-off,restore-database:,dump-database:,restart-miki,restart-machine,origin-path:,destination-path:,check-name,garbage-collect,new-name:,subscription-id:,data:,delete-auth0-user,replace-instance,replace-tarball:,snapshot-instance,snapshot-tarball:,use-cache,domain:,subdomain:,desktop:,sqlite-database-init: -- "$@")

  if [[ $? != 0 ]]; then
    error "Failed to parse arguments. Aborting."
  fi

  eval set -- "${opts}"

  while true; do
    case "$1" in
      (--help) OPT_HELP=true; shift ;;
      (--debug) OPT_DEBUG=true; shift ;;
      (--verbose) OPT_VERBOSE=true; shift ;;
      (--version) OPT_VERSION=true; shift ;;
      (-n|--name) OPT_NAME="${2,,}"; shift 2 ;;
      (-e|--email) OPT_EMAIL=$2; shift 2 ;;
      (--wiki-name) OPT_WIKI_NAME=$2; shift 2 ;;
      (--wiki-domain) OPT_WIKI_DOMAIN=$2; shift 2 ;;
      (--wiki-resources) OPT_WIKI_RESOURCES=$2; shift 2 ;;
      (--company-name) OPT_COMPANY_NAME=$2; shift 2 ;;
      (--company-domain) OPT_COMPANY_DOMAIN=$2; shift 2 ;;
      (--enable-wiki-ssl) OPT_ENABLE_WIKI_SSL=true; shift ;;
      (--enable-db-ssl) OPT_ENABLE_DB_SSL=true; shift ;;
      (--package-version) OPT_PACKAGE_VERSION=$2; shift 2 ;;
      (-p|--pgadm-path) OPT_PGADM_PATH=$2; shift 2 ;;
      (--install-path) OPT_MAKE_TARBALL=true; OPT_INSTALL_PATH=$2; shift 2 ;;
      (-i|--install-remotely) OPT_MAKE_TARBALL=true; OPT_INSTALL_REMOTELY=true; shift ;;
      (-K|--remove-self-ssh-key) OPT_REMOVE_SELF_SSH_KEY=true; shift ;;
      (-k|--ssh-keys) OPT_SSH_KEYS=$2; shift 2 ;;
      (--droplet-name) OPT_DROPLET_NAME=$2; shift 2 ;;
      (--database-name) OPT_DATABASE_NAME=$2; shift 2 ;;
      (--database-user) OPT_DATABASE_USER=$2; shift 2 ;;
      (--database-init) OPT_DATABASE_INIT=$2; shift 2 ;;
      (--no-database-init) OPT_DATABASE_INIT= ; shift ;;
      (--firewall-name) OPT_FIREWALL_NAME=$2; shift 2 ;;
      (-A|--firewall-addresses) OPT_FIREWALL_ADDRESSES=$2; shift 2 ;;
      (-P|--firewall-ports) OPT_FIREWALL_PORTS=$2; shift 2 ;;
      (-f|--create-firewall) OPT_CREATE_FIREWALL=true; shift ;;
      (-Y|--send-filter) OPT_SEND_FILTER=true; OPT_YAML_FILTER=$2; shift 2 ;;
      (-y|--query-filter) OPT_QUERY_FILTER=$2; shift 2 ;;
      (--config-enable-ssl) OPT_SEND_FILTER=true; OPT_CONFIG_ENABLE_SSL=true; shift ;;
      (--config-disable-ssl) OPT_SEND_FILTER=true; OPT_CONFIG_DISABLE_SSL=true; shift ;;
      (--config-domain-name) OPT_SEND_FILTER=true; OPT_CONFIG_DOMAIN_NAME=$2; shift 2 ;;
      (-l|--list-instances|--list) OPT_LIST_INSTANCES=true; shift ;;
      (-s|--ssh) OPT_SSH=true; shift ;;
      (-c|--command) OPT_COMMAND=$2; shift 2 ;;
      (-S|--sql) OPT_SQL=true; shift ;;
      (-F|--sql-file) OPT_SQL_FILE=$2; shift 2 ;;
      (-x|--expunge-instance) OPT_EXPUNGE_INSTANCE=true; shift ;;
      (-X|--force-expunge-instance) OPT_FORCE_EXPUNGE_INSTANCE=true; shift ;;
      (-r|--reset-admin-password) OPT_RESET_ADMIN_PASSWORD=true; shift ;;
      (-t|--create-support-account) OPT_CREATE_SUPPORT_ACCOUNT=true; shift ;;
      (--power-on) OPT_POWER_ON=true; shift ;;
      (--power-off) OPT_POWER_OFF=true; shift ;;
      (--restore-database) OPT_RESTORE_DATABASE=$2; shift 2 ;;
      (--dump-database) OPT_DUMP_DATABASE=$2; shift 2 ;;
      (--restart-miki) OPT_RESTART_MIKI=true; shift ;;
      (--restart-machine) OPT_RESTART_MACHINE=true; shift ;;
      (--origin-path) OPT_ORIGIN_PATH=$2; shift 2 ;;
      (--destination-path) OPT_DESTINATION_PATH=$2; shift 2 ;;
      (-C|--check-name) OPT_CHECK_NAME=true; shift ;;
      (-G|--garbage-collect) OPT_GARBAGE_COLLECT=true; shift ;;
      (-N|--new-name) OPT_NEW_NAME=$2; shift 2 ;;
      (-I|--subscription-id) OPT_SUBSCRIPTION_ID=$2; shift 2 ;;
      (--delete-auth0-user) OPT_DELETE_AUTH0_USER=true; shift ;;
      (-R|--replace-instance) OPT_REPLACE_INSTANCE=true; shift ;;
      (--replace-tarball) OPT_REPLACE_TARBALL=$2; shift 2 ;;
      (-T|--snapshot-instance) OPT_SNAPSHOT_INSTANCE=true; shift ;;
      (--snapshot-tarball) OPT_SNAPSHOT_TARBALL=$2; shift 2 ;;
      (-U|--use-cache) OPT_USE_CACHE=true; shift ;;
      (--domain) OPT_DOMAIN=$2; shift 2 ;;
      (--subdomain) OPT_SUBDOMAIN=$2; shift 2 ;;
      (-D|--desktop) OPT_DESKTOP=$2; shift 2 ;;
      (--sqlite-database-init) OPT_SQLITE_DATABASE_INIT=$2; shift 2 ;;
      (--) shift; break ;;
      (*) break ;;
    esac
  done
}

function get_droplet_id () {
  debug "${FUNCNAME[0]}" "$@"

  doadm -Ld | awk "/[0-9]+\s+${1}\s+/" | awk '{print $1}'
}

function get_droplet_name () {
  debug "${FUNCNAME[0]}" "$@"

  doadm -Ld | awk "/[0-9]+\s+${1}\s+/" | awk '{print $2}'
}

function get_droplet_address () {
  debug "${FUNCNAME[0]}" "$@"

  doadm -Ld | awk "/[0-9]+\s+${1}\s+/" | awk '{print $3}'
}

function make_miki_www_name () {
  debug "${FUNCNAME[0]}" "$@"

  echo "${VAL_BASE_NAME}-${OPT_NAME}"
}

function make_miki_fw_name () {
  debug "${FUNCNAME[0]}" "$@"

  echo "${VAL_BASE_NAME}-${OPT_NAME}-${VAL_FW_NAME}"
}

function set_domain_name () {
  debug "${FUNCNAME[0]}" "$@"

  local metadata="$(get_chargify_metadata)"

  if [[ -n "${OPT_WIKI_DOMAIN}" ]]; then
    VAL_DOMAIN_NAME="${OPT_WIKI_DOMAIN}"
  elif [[ ! "${metadata}" == "null" && -n "${metadata}" ]]; then
    VAL_DOMAIN_NAME="$(find_available_domain ${metadata,,}).${OPT_DOMAIN}"
  elif [[ -n "${OPT_SUBDOMAIN}" ]]; then
    VAL_DOMAIN_NAME="$(find_available_domain ${OPT_SUBDOMAIN,,}).${OPT_DOMAIN}"
  elif [[ -n "${OPT_NAME}" ]]; then
    VAL_DOMAIN_NAME="$(find_available_domain ${OPT_NAME,,}).${OPT_DOMAIN}"
  else
    VAL_DOMAIN_NAME="${VAL_MIKI_DOMAIN}"
  fi
}

function set_droplet_name () {
  debug "${FUNCNAME[0]}" "$@"

  if [[ -n "${OPT_DROPLET_NAME}" ]]; then
    VAL_DROPLET_NAME="${OPT_DROPLET_NAME}"
  elif [[ -n "${OPT_NAME}" ]]; then
    VAL_DROPLET_NAME="$(make_miki_www_name)"
  else
    VAL_DROPLET_NAME=
  fi
}

function set_firewall_name () {
  debug "${FUNCNAME[0]}" "$@"

  if [[ -n "${OPT_FIREWALL_NAME}" ]]; then
    VAL_FIREWALL_NAME="${OPT_FIREWALL_NAME}"
  elif [[ -n "${OPT_NAME}" && -n "${OPT_CREATE_FIREWALL}" ]]; then
    VAL_FIREWALL_NAME="$(make_miki_fw_name)"
  else
    VAL_FIREWALL_NAME=
  fi
}

function set_component_names () {
  debug "${FUNCNAME[0]}" "$@"

  set_domain_name
  set_droplet_name
  set_firewall_name
}

function process_arguments () {
  debug "${FUNCNAME[0]}" "$@"

  if [[ -n "${OPT_HELP}" || "${#}" -lt 1 ]]; then
    display_usage
  elif [[ -n "${OPT_VERSION}" ]]; then
    display_version
  elif [[ -n "${OPT_GARBAGE_COLLECT}" ]]; then
    garbage_collect
  elif [[ -n "${OPT_LIST_INSTANCES}" ]]; then
    list_instances
  elif [[ -n "${OPT_RESTORE_DATABASE}" ]]; then
    restore_database
  elif [[ -n "${OPT_DUMP_DATABASE}" ]]; then
    dump_database
  elif [[ -n "${OPT_RESET_ADMIN_PASSWORD}" ]]; then
    reset_admin_password
    exit 0
  elif [[ -n "${OPT_CREATE_SUPPORT_ACCOUNT}" ]]; then
    create_support_account
  # elif [[ -n "${OPT_INSTALL_REMOTELY}" ]]; then
  #   check_droplet
  elif [[ -n "${OPT_SSH}" ]]; then
    connect_ssh
  elif [[ -n "${OPT_SQL}" ]]; then
    connect_sql
  elif [[ -n "${OPT_SQL_FILE}" ]]; then
    remote_load_sql_file
  elif [[ -n "${OPT_COMMAND}" ]]; then
    send_command
  elif [[ -n "${OPT_EXPUNGE_INSTANCE}" && -z "${OPT_FORCE_EXPUNGE_INSTANCE}" ]]; then
    expunge_instance
  elif [[ -n "${OPT_FORCE_EXPUNGE_INSTANCE}" && -z "${OPT_EXPUNGE_INSTANCE}" ]]; then
    force_expunge_instance
  elif [[ "${OPT_SEND_FILTER}" ]]; then
    send_filter
  elif [[ "${OPT_QUERY_FILTER}" ]]; then
    query_filter
  elif [[ -n "${OPT_POWER_ON}" ]]; then
    power_on_droplet
  elif [[ -n "${OPT_POWER_OFF}" ]]; then
    power_off_droplet
  elif [[ -n "${OPT_RESTART_MIKI}" ]]; then
    restart_miki
  elif [[ -n "${OPT_RESTART_MACHINE}" ]]; then
    restart_machine
  elif [[ -n "${OPT_CHECK_NAME}" ]]; then
    check_name
  elif [[ -n "${OPT_ORIGIN_PATH}" && -n "${OPT_DESTINATION_PATH}" ]]; then
    copy_file
  elif [[ -n "${OPT_NEW_NAME}" ]]; then
    rename_instance
  elif [[ -n "${OPT_DELETE_AUTH0_USER}" ]]; then
    delete_auth0_user
  elif [[ -n "${OPT_REPLACE_INSTANCE}" && -n "${OPT_REPLACE_TARBALL}" ]]; then
    replace_instance
  elif [[ -n "${OPT_SNAPSHOT_INSTANCE}" ]]; then
    snapshot_instance
  elif [[ -n "${OPT_MIKI_DIRECTORY}" && ! "$(basename ${OPT_MIKI_DIRECTORY})" == "${VAL_BASE_NAME}" ]]; then
    display_usage
  elif [[ -z "${OPT_WIKI_NAME}" || -z "${OPT_WIKI_RESOURCES}" || -z "${OPT_COMPANY_NAME}" || -z "${OPT_COMPANY_DOMAIN}" ]]; then
    display_usage
  else
    return 0
  fi
}

function display_usage () {
  debug "${FUNCNAME[0]}" "$@"

  cat << EOF
${SELF} v${VERSION} [OPTIONS]...

OPTIONS:
      --help                        Show this help
      --debug                       Enable debugging mode
      --verbose                     Enable verbose output
      --version                     Display program version info
  -n, --name <TEXT>                 The name of the instance
  -e, --email <EMAIL>               The email address of the admin account
      --wiki-name <TEXT>            The wiki name
      --wiki-domain <FQDN>          The wiki domain
      --wiki-resources <PATH>       The remote path for wiki resources
      --company-name <TEXT>         The company name
      --company-domain <FQDN>       The company domain
      --enable-wiki-ssl             Flag to enable wiki SSL on installation
      --enable-db-ssl               Flag to enable database SSL on installation
      --package-version <SEMVER>    The version number for package.json
      --install-path <PATH>         The remote path of Miki on the instance
  -p, --pgadm-path <PATH>           The local path of the pgadm program
  -i, --install-remotely            Flag to perform remote installation
  -K, --remove-self-ssh-key         Remove the SSH key of the host from the allowed SSH keys
  -k, --ssh-keys <CSV>              Comma-separated list of allowed SSH keys on the instance
      --droplet-name <TEXT>         The name of the droplet
      --database-name <TEXT>        The name of the database
      --database-user <TEXT>        The name of the database user
      --database-init <PATH>        The local path to the database dump to import on the instance
      --no-database-init            Flag to not initialize the instance with a database dump
      --firewall-name <TEXT>        The name of firewall for the droplet
  -A, --firewall-addresses <CSV>    Comma-separated list of IP addresses to allow on the droplet
  -P, --firewall-ports <CSV>        Comma-separated list of allowed ports on the droplet
  -f, --create-firewall             Flag to create a firewall from the instance name
  -Y, --yaml-filter <JQ>            Send an updating YAML filter to the instance
  -y, --query-filter <JQ>           Send a query YAML filter to the instance
      --config-enable-ssl           Flag to enable SSL on the instance
      --config-disable-ssl          Flag to Disable SSL on the instance
      --config-domain-name <FQDN>   Set the domain name of the instance
  -l, --list-instances              Flag to list all instances
  -s, --ssh                         Flag to connect to the instance via SSH
  -c, --command <COMMAND>           Run an arbitrary command to the instance
  -S, --sql                         Flag to connect to the SQL prompt of the instance
  -F  --sql-file <PATH>             The local SQL file to upload and execute on the instance
  -x, --expunge-instance            Flag to expunge the instance
  -X, --force-expunge-instance      Flag to expunge the instance without confirmations
  -r, --reset-admin-password        Flag to reset the admin password of the instance
  -t, --create-support-account      Flag to create a support account on the instance
      --power-on                    Flag to turn the instance on
      --power-off                   Flag to turn the instance off
      --restore-database <PATH>     The local path for the database file for restoration
      --dump-database <PATH>        The local path for the database file for dumping
      --restart-miki                Flag to restart the Miki service
      --restart-machine             Flag to restart the remote machine
      --origin-path <PATH>          The local origin path for file copying
      --destination-path <PATH>     The remote destination path for file copying
  -C, --check-name                  Flag to return true if an instance already exits
  -G, --garbage-collect             Flag to delete leftover files and directories
  -N, --new-name <TEXT>             The new name for the instance
      --subscription-id <ID>        The Chargify subscription ID
  -R, --replace-instance            Flag to replace an instance with a snapshot
      --replace-tarball <PATH>      The local tarball path for the instance replacement
  -T, --snapshot-instance           Flag to create a tarball snapshot of an instance
      --snapshot-tarball <PATH>     The local tarball path for the instance snapshot
  -U, --use-cache                   Flag to use a prebuilt droplet snapshot for the instance
      --domain                      The top-level domain to use for the subdomains
      --subdomain                   The subdomain to use on the top-level domain
  -D, --desktop <OS>                Build a desktop version for OS
      --sqlite-database-init <PATH> The local path to the SQLite3 database to use for init
EOF
  exit 0
}


function display_version () {
  debug "${FUNCNAME[0]}" "$@"

  cat << EOF
${SELF} v${VERSION}
EOF
  exit 0
}

function create_miki_directory () {
  debug "${FUNCNAME[0]}" "$@"

  OPT_MIKI_DIRECTORY="$(mktemp -d --suffix .miki)/miki"
}

function clone_miki_repository () {
  debug "${FUNCNAME[0]}" "$@"

  git clone "${VAL_MIKI_REPOSITORY}" "${OPT_MIKI_DIRECTORY}"
}

function delete_miki_directory () {
  debug "${FUNCNAME[0]}" "$@"

  [[ -d "${OPT_MIKI_DIRECTORY}" ]] && rm -rf "${OPT_MIKI_DIRECTORY}"
}

function initialize () {
  debug "${FUNCNAME[0]}" "$@"

  display_banner "Performing initialization ..."

  create_miki_directory
  clone_miki_repository
  push "${OPT_MIKI_DIRECTORY}"

  if [[ -f "package.json" && "$(jq -r '.name' package.json)" == "wiki" ]]; then
    return 0
  else
    error "The current directory does not contain the correct contents. Aborting."
  fi
}

function reset_repository () {
  debug "${FUNCNAME[0]}" "$@"

  git reset --hard "${VAL_BASE_COMMIT}" &> /dev/null
}

function npm_install () {
  debug "${FUNCNAME[0]}" "$@"

  npm install
}

function delete_files () {
  debug "${FUNCNAME[0]}" "$@"

  rm -rf db
  rm -rf data
}

function create_readme () {
  debug "${FUNCNAME[0]}" "$@"

  cat << EOF > README.md
# miki
EOF
}

function create_local_config_yml () {
  debug "${FUNCNAME[0]}" "$@"

  cat << EOF > config.yml
port: 3000

db:
  type: sqlite
  storage: db/db.sqlite

ssl:
  enabled: false

bindIP: 0.0.0.0

logLevel: info

offline: false

ha: false

dataPath: ./data
EOF
}

function find_id () {
  debug "${FUNCNAME[0]}" "$@"

  local path=$1
  local regex=$2

  find ${path} -name "${regex}" | awk -F \. '{print $2}'
}

function copy_vue_files () {
  debug "${FUNCNAME[0]}" "$@"

  rsync -a "${VAL_RESOURCES_DIR}/client" .
  rsync -a "${VAL_RESOURCES_DIR}/dev" .
}

function extract_seed () {
  debug "${FUNCNAME[0]}" "$@"

  display_banner "Extracting seed ..."

  OPT_MIKI_DIRECTORY="$(mktemp -d --suffix .miki)/miki"

  tar -C "$(dirname ${OPT_MIKI_DIRECTORY})" -xf "${VAL_SEED_FILE}"
  push "${OPT_MIKI_DIRECTORY}"
}

function update_files () {
  debug "${FUNCNAME[0]}" "$@"

  declare -A SUBSTITUTIONS=(
    ['wikijs-butterfly.svg']="${OPT_COMPANY_NAME}.svg"

    ['wiki\.js']="${OPT_WIKI_NAME,,}"
    ['wiki-js']="${OPT_WIKI_NAME,,}"
    ['wikijs']="${OPT_WIKI_NAME,,}"
    ['Wiki\.js']="${OPT_WIKI_NAME^}"
    ['WIKI\.js']="${OPT_WIKI_NAME^}"

    ['wiki\.js\.org']="${VAL_MIKI_DOMAIN}"
    ['wiki\.yourdomain\.com']="${VAL_DOMAIN_NAME}"

    ['https://static\.requarks\.io/logo']="${OPT_WIKI_RESOURCES}"

    ['https://github\.com/Requarks/wiki']="${VAL_MIKI_REPOSITORY}"

    ['Requarks']="${OPT_COMPANY_NAME^}"
    # ['requarks\.io']="${OPT_COMPANY_DOMAIN}"
    # ['requarks']="${OPT_COMPANY_NAME}"
  )

  for i in "${!SUBSTITUTIONS[@]}"; do
    for file in $(rg -l "$i"); do
      sed -i -e "s|${i}|${SUBSTITUTIONS[$i]}|g" "$file"
    done
  done

  if [[ -n "${OPT_SUBSCRIPTION_ID}" ]]; then
    sed -i -e "s/{{\ info.currentVersion\ }}/${OPT_SUBSCRIPTION_ID}/" client/components/admin/admin-system.vue
  fi
}

function clone_locales_repository () {
  debug "${FUNCNAME[0]}" "$@"

  mkdir -p data
  git clone "${VAL_MIKI_LOCALES_REPOSITORY}" "data/sideload"
}

function update_package_json () {
  debug "${FUNCNAME[0]}" "$@"

  local temp=$(mktemp)
  local version=${OPT_PACKAGE_VERSION:-${VAL_DEFAULT_PACKAGE_VERSION}}

  cat package.json | jq ".version = \"${version}\""  | jq '.dev = false' > "${temp}"
  mv -f ${temp} package.json
}

function display_banner () {
  local message="${1}"

  echo "================================================================================"
  echo -e " ${message}"
  echo "================================================================================"
}

function yarn_build () {
  debug "${FUNCNAME[0]}" "$@"

  display_banner "Compiling sources ..."
  GENERATE_SOURCEMAP=false yarn build
}

function install_assets () {
  debug "${FUNCNAME[0]}" "$@"

  rsync -a ${VAL_RESOURCES_DIR}/assets/favicon.ico assets
  rsync -a ${VAL_RESOURCES_DIR}/assets/favicons assets
  rsync -a ${VAL_RESOURCES_DIR}/assets/svg assets
  rsync -a ${VAL_RESOURCES_DIR}/assets/img/splash assets/img
  rsync -a ${VAL_RESOURCES_DIR}/assets/fonts assets
  rsync -a ${VAL_RESOURCES_DIR}/assets/css assets
}

function create_db_directory () {
  debug "${FUNCNAME[0]}" "$@"

  mkdir -p db
}

function create_password () {
  debug "${FUNCNAME[0]}" "$@"

  < /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c ${1:-32}
}

function create_password_file () {
  debug "${FUNCNAME[0]}" "$@"

  VAL_PASSWORD_FILE=$(mktemp)

  echo $(create_password) > "${VAL_PASSWORD_FILE}"
}

function create_remote_config_yml () {
  debug "${FUNCNAME[0]}" "$@"

  cat << EOF > config.yml
#port: 3000

db:
  type: postgres
  host: localhost
  port: 5432
  user: ${OPT_DATABASE_USER}
  pass: $(cat ${VAL_PASSWORD_FILE})
  db: ${OPT_DATABASE_NAME}
  ssl: ${OPT_ENABLE_DB_SSL}
  sslOptions:
    auto: true
    ca: ./keys/ca.crt
    cert: ./keys/cert.pem
    key: ./keys/key.pem

ssl:
  enabled: ${OPT_ENABLE_WIKI_SSL}
  port: 443
  provider: letsencrypt
  domain: ${VAL_DOMAIN_NAME}
  subscriberEmail: ${OPT_EMAIL}

bindIP: 0.0.0.0

logLevel: info

offline: false

ha: false

dataPath: ./data
EOF
}

function delete_password_file () {
  debug "${FUNCNAME[0]}" "$@"

  rm -f "${VAL_PASSWORD_FILE}"
}

function create_init_sql () {
  debug "${FUNCNAME[0]}" "$@"

  mkdir -p sql
  cat << EOF > sql/init.sql
CREATE database ${OPT_DATABASE_NAME};
CREATE user ${OPT_DATABASE_USER} password '$(cat ${VAL_PASSWORD_FILE})';
GRANT ALL PRIVILEGES ON DATABASE ${OPT_DATABASE_NAME} TO ${OPT_DATABASE_USER};
EOF
}

function copy_bin () {
  debug "${FUNCNAME[0]}" "$@"

  rm -rf bin
  rsync -aL "${SELF_DIR}/bin" .
}

function create_tarball () {
  debug "${FUNCNAME[0]}" "$@"

  local file="$(basename ${OPT_MIKI_DIRECTORY}).${VAL_RANDOM}.tar.gz"

  cd "$(dirname ${OPT_MIKI_DIRECTORY})"

  if [[ -d "${OPT_MIKI_DIRECTORY}" ]]; then
    tar -C "$(dirname ${OPT_MIKI_DIRECTORY})" -czf "${file}" --exclude ".git" \
        "$(basename ${OPT_MIKI_DIRECTORY})"
  else
    error "ERROR: Cannot create a tarball. Aborting."
  fi
}

function self_ssh_key () {
  debug "${FUNCNAME[0]}" "$@"

  local key_file=

  if [[ -n "$HOME/.ssh/id_ed25519" ]]; then
    key_file="$HOME/.ssh/id_ed25519"
  elif [[ -n "$HOME/.ssh/id_rsa" ]]; then
    key_file="$HOME/.ssh/id_rsa"
  fi

  if [[ -n "${key_file}" ]]; then
    ssh-keygen -l -E md5 -f "${key_file}" | awk '{print $2}' | sed 's/^...://'
  fi
}

function set_ssh_keys () {
  debug "${FUNCNAME[0]}" "$@"

  if [[ -z "${OPT_REMOVE_SELF_SSH_KEY}" ]]; then
    if [[ -n "${OPT_SSH_KEYS}" ]]; then
      OPT_SSH_KEYS="${OPT_SSH_KEYS},$(self_ssh_key)"
    else
      OPT_SSH_KEYS="$(self_ssh_key)"
    fi
  else
    OPT_SSH_KEYS="${OPT_SSH_KEYS}"
  fi
}

function create_droplet () {
  debug "${FUNCNAME[0]}" "$@"

  if [[ -n "${OPT_INSTALL_PATH}" && -n "${VAL_DROPLET_NAME}" ]]; then
    if [[ -n "${OPT_USE_CACHE}" ]]; then
      OPT_DROPLET_ADDRESS=$(doadm -cdn "${VAL_DROPLET_NAME}" \
                                  -k "${OPT_SSH_KEYS}" \
                                  -i "${VAL_SNAPSHOT_ID}")
    else
      OPT_DROPLET_ADDRESS=$(doadm -cdn "${VAL_DROPLET_NAME}" \
                                  -k "${OPT_SSH_KEYS}")
    fi
    echo "${OPT_DROPLET_ADDRESS}"
  fi
}

function is_droplet_ready () {
  debug "${FUNCNAME[0]}" "$@"

  if [[ -n "${VAL_DROPLET_NAME}" && -n "${OPT_DROPLET_ADDRESS}" ]]; then
    return 0
  else
    return 1
  fi
}

function upload_tarball () {
  debug "${FUNCNAME[0]}" "$@"

  local file="$(basename ${OPT_MIKI_DIRECTORY}).${VAL_RANDOM}.tar.gz"
  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")

  sleep "${VAL_SLEEP}"

  if [[ -f "${file}" && -n "${OPT_INSTALL_PATH}" && -n "${OPT_DROPLET_USER}" ]] && is_droplet_ready; then
    run_scp "${file}" "${OPT_DROPLET_USER}@${address}:"
  fi
}

function delete_tarball () {
  debug "${FUNCNAME[0]}" "$@"

  local directory="$(dirname ${OPT_MIKI_DIRECTORY})"
  local file="$(basename ${OPT_MIKI_DIRECTORY}).${VAL_RANDOM}.tar.gz"

  rm -f "$(basename ${OPT_MIKI_DIRECTORY}).${VAL_RANDOM}.tar.gz"
}

function upload_database_init () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")

  if [[ -n "${OPT_DATABASE_INIT}" ]]; then
    run_scp "${OPT_DATABASE_INIT}" "${OPT_DROPLET_USER}@${address}:${VAL_REMOTE_TMP}"
  fi
}

function upload_pgadm () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")

  if [[ -n "${OPT_INSTALL_PATH}" ]] && is_droplet_ready; then
    run_scp "${OPT_PGADM_PATH}" "${OPT_DROPLET_USER}@${address}:${VAL_REMOTE_BIN}"
  fi
}

function upload_pgsql () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")

  if [[ -n "${OPT_INSTALL_PATH}" ]] && is_droplet_ready; then
    run_scp "${OPT_PGSQL_PATH}" "${OPT_DROPLET_USER}@${address}:${VAL_REMOTE_BIN}"
  fi
}

function install_miki () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")
  local file="$(basename ${OPT_MIKI_DIRECTORY}).${VAL_RANDOM}.tar.gz"
  local base_cmd=
  local cmd=

  if [[ "${OPT_USE_CACHE}" ]]; then
    base_cmd="tar -C /var -xf ${file}; bash ${OPT_INSTALL_PATH}/bin/install -Ui ${OPT_INSTALL_PATH}"
  else
    base_cmd="tar -C /var -xf ${file}; bash ${OPT_INSTALL_PATH}/bin/install -i ${OPT_INSTALL_PATH}"
  fi

  if [[ -n "${OPT_INSTALL_PATH}" ]] && is_droplet_ready && [[ -n "${OPT_DATABASE_INIT}" ]]; then
    cmd="${base_cmd} -I ${VAL_REMOTE_TMP}/$(basename ${OPT_DATABASE_INIT})"
  else
    cmd="${base_cmd}"
  fi

  if [[ -n "${OPT_INSTALL_PATH}" ]] && is_droplet_ready; then
    run_ssh "${OPT_DROPLET_USER}@${address}" "${cmd}"
  fi

  return 0
}

function create_firewall () {
  debug "${FUNCNAME[0]}" "$@"

  if [[ -n "${VAL_FIREWALL_NAME}" ]]; then
    doadm -cfn "${VAL_FIREWALL_NAME}" -a "${VAL_DROPLET_NAME}" \
          -SA "${OPT_FIREWALL_ADDRESSES}" -P "${OPT_FIREWALL_PORTS}"
  fi
}

function display_greeting () {
  debug "${FUNCNAME[0]}" "$@"

  echo "================================================================================"
  echo " Your new Miki instance is now ready."
  echo ""
  echo " Name: ${OPT_NAME}"
  echo " URL: https://${VAL_DOMAIN_NAME}"
  echo " Address: ${OPT_DROPLET_ADDRESS}"
  echo " Username: ${OPT_EMAIL}"
  echo " Password: ${VAL_ADMIN_PASSWORD}"
  echo "================================================================================"
}

function is_local_build () {
  debug "${FUNCNAME[0]}" "$@"

  if [[ -z "${OPT_INSTALL_REMOTELY}" ]]; then
    return 0
  else
    return 1
  fi
}

function local_build () {
  debug "${FUNCNAME[0]}" "$@"

  if [[ -n "${OPT_USE_CACHE}" ]]; then
    extract_seed
  else
    initialize
    reset_repository
    npm_install
    delete_files
    create_readme
    create_local_config_yml
    clone_locales_repository
  fi

  copy_vue_files
  update_files
  update_package_json
  yarn_build

  install_assets
  create_db_directory

  # create_tarball
}

function check_droplet () {
  debug "${FUNCNAME[0]}" "$@"

  local droplet=$(get_droplet_name ${VAL_DROPLET_NAME})

  if [[ -n "${droplet}" ]]; then
    error "A droplet with that name already exists. Aborting."
  else
    return 0
  fi
}

function start_miki_service () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")

  run_ssh "${OPT_DROPLET_USER}@${address}" "systemctl start miki.service"
}

function restart_miki_service () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")

  run_ssh "${OPT_DROPLET_USER}@${address}" "systemctl restart miki.service"
}

function notify_chargify () {
  debug "${FUNCNAME[0]}" "$@"

  local json=$(jq . << EOF
{
  "metadata": [
    {
      "name": "Choose a Name for This Miki",
      "value": "${OPT_NAME}"
    }
  ]
}
EOF
)

  if [[ -n "${OPT_SUBSCRIPTION_ID}" ]]; then
    curl "https://mimix.chargify.com/subscriptions/${OPT_SUBSCRIPTION_ID}/metadata.json" \
         -s -X POST \
         -u "${VAL_CHARGIFY_USERNAME}:X" \
         -H "Content-Type: application/json" \
         -d "${json}" || return 0
  fi
}

function filter_js () {
  debug "${FUNCNAME[0]}" "$@"

  local value="$1"

  if [[ -n "${value}" ]]; then
    node "${VAL_JS_FILTER}" "$1"
  else
    echo ""
  fi
}

function get_chargify_metadata () {
  debug "${FUNCNAME[0]}" "$@"

  local val=

  if [[ -n "${OPT_SUBSCRIPTION_ID}" ]]; then
    val=$(curl "https://mimix.chargify.com/subscriptions/${OPT_SUBSCRIPTION_ID}/metadata.json" \
               -s -X GET \
               -u "${VAL_CHARGIFY_USERNAME}:X" \
            | jq -r '.metadata | .[0] .value')
    filter_js "${val}"
  fi
}

function get_auth0_token () {
  debug "${FUNCNAME[0]}" "$@"

  local auth0_file=$HOME/.auth0.json

  curl "https://mimix.us.auth0.com/oauth/token" \
       -s -X POST \
       -H 'content-type: application/json' \
       -d @"${auth0_file}" | jq -r '.access_token'
}

function notify_auth0 () {
  debug "${FUNCNAME[0]}" "$@"

  local token=$(get_auth0_token)

  local json1=$(jq . << EOF
{
  "user_id": "${OPT_NAME}",
  "email": "${OPT_EMAIL}",
  "connection": "Username-Password-Authentication",
  "password": "${VAL_ADMIN_PASSWORD}",
  "email_verified": false,
  "app_metadata": {
    "url": "https://${VAL_DOMAIN_NAME}",
    "ip": "${OPT_DROPLET_ADDRESS}",
    "pw": "${VAL_ADMIN_PASSWORD}",
    "domain": "${OPT_DOMAIN}",
    "subdomain": "${OPT_SUBDOMAIN}"
  }
}
EOF
)

  local json2=$(jq . << EOF
{
  "user_id": "auth0|${OPT_NAME}"
}
EOF
)

  curl "https://mimix.us.auth0.com/api/v2/users" \
       -s -X POST \
       -H "Authorization: Bearer ${token}" \
       -H "Content-Type: application/json" \
       -d "${json1}" || return 0


  curl "https://mimix.us.auth0.com/api/v2/jobs/verification-email" \
       -s -X POST \
       -H "Authorization: Bearer ${token}" \
       -H "Content-Type: application/json" \
       -d "${json2}" || return 0
}

function delete_auth0_user () {
  debug "${FUNCNAME[0]}" "$@"

  local token=$(get_auth0_token)

  if [[ -n "${OPT_NAME}" ]]; then
    curl "https://mimix.us.auth0.com/api/v2/users/auth0%7C${OPT_NAME}" \
         -s -X DELETE \
         -H "Authorization: Bearer ${token}"
  fi

  exit 0
}

function notify_hook () {
  debug "${FUNCNAME[0]}" "$@"

  local json_hosted=$(jq . << EOF
{
  "data": {
    "subscription_id": "${OPT_SUBSCRIPTION_ID}",
    "name": "${OPT_NAME}",
    "url": "https://${VAL_DOMAIN_NAME}",
    "address": "${OPT_DROPLET_ADDRESS}",
    "username": "${OPT_EMAIL}",
    "password": "${VAL_ADMIN_PASSWORD}"
  }
}
EOF
)

  local json_desktop=$(jq . << EOF
{
  "data": {
    "subscription_id": "${OPT_SUBSCRIPTION_ID}",
    "name": "${OPT_NAME}",
    "username": "${OPT_EMAIL}",
    "password": "${VAL_ADMIN_PASSWORD}"
  }
}
EOF
)


  if [[ -z "${OPT_DESKTOP}" ]]; then
    json="${json_hosted}"
  else
    json="${json_desktop}"
  fi

  curl "${VAL_HOOK_URL}/control" \
       -s -X POST \
       -H "Content-Type: application/json" \
       -d "${json}"
}

function list_domains () {
  debug "${FUNCNAME[0]}" "$@"

  doadm -lDn "${OPT_DOMAIN}" | awk '{print $3}'
}

function is_domain_available () {
  debug "${FUNCNAME[0]}" "$@"

  local domain="${1}"

  if [[ -z $(list_domains | grep "^${domain}$") ]]; then
    return 0
  else
    return 1
  fi
}

function find_available_domain () {
  debug "${FUNCNAME[0]}" "$@"

  local query="${1}"

  if is_domain_available "${query}"; then
    echo -n "${query}"
  else
    for ((i = 1; i <= 1000; i++)); do
      if is_domain_available "${query}${i}"; then
        echo -n "${query}${i}"
        break
      fi
    done
  fi
}

function create_domain () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")
  local metadata="$(get_chargify_metadata)"
  local subdomain=

  if [[ ! "${metadata}" == "null" && -n "${metadata}" ]]; then
    subdomain="$(find_available_domain ${metadata,,})"
  elif [[ -n "${OPT_SUBDOMAIN}" ]]; then
    subdomain="$(find_available_domain ${OPT_SUBDOMAIN,,})"
  elif [[ -n "${OPT_NAME}" ]]; then
    subdomain="$(find_available_domain ${OPT_NAME,,})"
  else
    subdomain=""
  fi

  if [[ -n "${subdomain}" ]]; then
    doadm -cDn "${OPT_DOMAIN}" -s "${subdomain}" -A "${address}"
  else
    warn "WARNING: Unable to create domain. Skipping."
  fi
}

function remote_install () {
  debug "${FUNCNAME[0]}" "$@"

  check_droplet

  push "${OPT_MIKI_DIRECTORY}"

  create_password_file
  create_remote_config_yml
  create_init_sql
  delete_password_file
  copy_bin

  create_tarball

  set_ssh_keys
  create_droplet
  upload_tarball
  delete_tarball

  upload_database_init
  upload_pgadm
  upload_pgsql

  install_miki
  create_firewall

  reset_admin_password
  start_miki_service
  notify_auth0
  notify_hook
  create_domain

  display_greeting
  delete_miki_directory

  exit 0
}

function send_yaml_filter () {
  debug "${FUNCNAME[0]}" "$@"

  local filter="${1:-${OPT_YAML_FILTER}}"

  if [[ -n "${filter}" && -n "${VAL_DROPLET_NAME}" ]]; then
    for address in $(get_droplet_address "${VAL_DROPLET_NAME}"); do
      run_ssh "${OPT_DROPLET_USER}@${address}" "yq -iy ${filter} /var/miki/config.yml"
    done
  fi
}

function enable_ssl () {
  debug "${FUNCNAME[0]}" "$@"

  if [[ -n "${OPT_CONFIG_ENABLE_SSL}" && -n "${VAL_DROPLET_NAME}" ]]; then
    send_yaml_filter ".ssl.enabled=true"
  fi
}

function disable_ssl () {
  debug "${FUNCNAME[0]}" "$@"

  if [[ -n "${OPT_CONFIG_DISABLE_SSL}" && -n "${VAL_DROPLET_NAME}" ]]; then
    send_yaml_filter ".ssl.enabled=false"
  fi
}

function set_ssl_domain () {
  debug "${FUNCNAME[0]}" "$@"

  if [[ -n "${OPT_CONFIG_DOMAIN_NAME}" && -n "${VAL_DROPLET_NAME}" ]]; then
    send_yaml_filter ".ssl.domain=\\\"${OPT_CONFIG_DOMAIN_NAME}\\\""
  fi
}

function send_filter () {
  debug "${FUNCNAME[0]}" "$@"

  if [[ -n "${OPT_NAME}" ]]; then
    if [[ -n "${OPT_YAML_FILTER}" ]]; then
      send_yaml_filter
    fi

    if [[ -n "${OPT_CONFIG_ENABLE_SSL}" ]]; then
      enable_ssl
    fi

    if [[ -n "${OPT_CONFIG_DISABLE_SSL}" ]];then
      disable_ssl
    fi

    if [[ -n "${OPT_CONFIG_DOMAIN_NAME}" ]]; then
      set_ssl_domain
    fi
  fi

  exit $?
}

function query_filter () {
  debug "${FUNCNAME[0]}" "$@"

  local filter="${OPT_QUERY_FILTER}"
  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")

  if [[ -n "${filter}" && -n "${VAL_DROPLET_NAME}" ]]; then
    for address in $(get_droplet_address "${VAL_DROPLET_NAME}"); do
      run_ssh "${OPT_DROPLET_USER}@${address}" "yq -r ${filter} /var/miki/config.yml"
    done
  fi

  exit $?
}

function connect_ssh () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")

  run_ssh "${OPT_DROPLET_USER}@${address}"

  exit $?
}

function connect_sql () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")

  run_ssh "${OPT_DROPLET_USER}@${address}" "/usr/local/bin/pgsql"

  exit $?
}

function send_command () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")

  run_ssh "${OPT_DROPLET_USER}@${address}" "${OPT_COMMAND}"

  exit $?
}

function expunge_instance () {
  debug "${FUNCNAME[0]}" "$@"

  doadm -xdn "${VAL_DROPLET_NAME}"

  exit $?
}

function force_expunge_instance () {
  debug "${FUNCNAME[0]}" "$@"

  doadm -xdn "${VAL_DROPLET_NAME}" --force

  exit $?
}

function list_instances () {
  debug "${FUNCNAME[0]}" "$@"

  doadm -ld | awk "/[0-9]+\s+miki/" | sed 's/\ *miki-/ /' | column -t

  exit $?
}

function generate_hash () {
  debug "${FUNCNAME[0]}" "$@"

  echo "${1}" | htpasswd -niBC 10 "" | tr -d ':\n'
}

function load_remote_sql () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")
  local file="${1}"

  run_ssh "${OPT_DROPLET_USER}@${address}" "/usr/local/bin/pgsql -f ${file}; rm -f ${file}"
}

function generate_admin_password () {
  debug "${FUNCNAME[0]}" "$@"

  VAL_ADMIN_PASSWORD="$(goxkcdpwgen -n 2)"
  VAL_ADMIN_PASSWORD_HASH=$(generate_hash "${VAL_ADMIN_PASSWORD}")
}

function generate_date () {
  debug "${FUNCNAME[0]}" "$@"

  date +"%Y-%m-%dT%H:%M:%S.000%Z"
}

function create_admin_sql_file () {
  debug "${FUNCNAME[0]}" "$@"

  local name=Administrator
  local id=1
  local date=$(generate_date)

  VAL_ADMIN_SQL_LOCAL_FILE=$(mktemp --suffix .sql)

  if [[ -n "${OPT_RESET_ADMIN_PASSWORD}" ]]; then
    cat << EOF > ${VAL_ADMIN_SQL_LOCAL_FILE}
UPDATE users SET email = '${OPT_EMAIL}' WHERE id = '${id}';
UPDATE users SET password = '${VAL_ADMIN_PASSWORD_HASH}' WHERE id = '${id}';
UPDATE users SET "mustChangePwd" = 't' WHERE id = '${id}';
EOF
  else
    cat << EOF > ${VAL_ADMIN_SQL_LOCAL_FILE}
UPDATE users SET email = '${OPT_EMAIL}' WHERE id = '${id}';
UPDATE users SET password = '${VAL_ADMIN_PASSWORD_HASH}' WHERE id = '${id}';
UPDATE users SET "mustChangePwd" = 't' WHERE id = '${id}';
UPDATE settings SET value = '{"v":"https://${VAL_DOMAIN_NAME}"}' WHERE key = 'host';
INSERT INTO settings VALUES('server', '{"sslRedir":true}', '2020-01-01T00:00:00.00Z');
EOF
  fi
}

function upload_admin_sql_file () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")

  VAL_ADMIN_SQL_REMOTE_FILE=$(mktemp --dry-run --suffix .sql)

  run_scp "${VAL_ADMIN_SQL_LOCAL_FILE}" "${OPT_DROPLET_USER}@${address}:${VAL_ADMIN_SQL_REMOTE_FILE}"
  rm -f "${VAL_ADMIN_SQL_LOCAL_FILE}"
}

function remote_reset_admin_password () {
  debug "${FUNCNAME[0]}" "$@"

  load_remote_sql "${VAL_ADMIN_SQL_REMOTE_FILE}"
}

function display_admin_password () {
  debug "${FUNCNAME[0]}" "$@"

  if [[ -n "${OPT_RESET_ADMIN_PASSWORD}" ]]; then
    echo "${VAL_ADMIN_PASSWORD}"
  fi
}

function reset_admin_password () {
  debug "${FUNCNAME[0]}" "$@"

  if [[ -n "${OPT_EMAIL}" && -n "${VAL_DROPLET_NAME}" ]]; then
    generate_admin_password
    create_admin_sql_file
    upload_admin_sql_file
    remote_reset_admin_password
    restart_miki_service
    display_admin_password
  fi
}

function generate_support_password () {
  debug "${FUNCNAME[0]}" "$@"

  VAL_SUPPORT_PASSWORD="$(goxkcdpwgen -n 2)"
  VAL_SUPPORT_PASSWORD_HASH=$(generate_hash "${VAL_SUPPORT_PASSWORD}")
}

function create_support_sql_file () {
  debug "${FUNCNAME[0]}" "$@"

  VAL_SUPPORT_SQL_LOCAL_FILE=$(mktemp --suffix .sql)

  cat << EOF > ${VAL_SUPPORT_SQL_LOCAL_FILE}
DELETE FROM users WHERE email = 'support@mimix.io';
INSERT INTO users VALUES('100', 'support@mimix.io','Miki Support', '', '${VAL_SUPPORT_PASSWORD_HASH}', 'f', '', '', '', '', 'America/New_York', 'f', 't', 't', 'f', '2020-01-01T00:00:00.00Z', '2020-11-13T11:19:07.084Z', 'local', 'en', 'markdown', '2020-11-13T11:19:49.393Z', '');
INSERT INTO "userGroups" VALUES('100', '100', '1');
EOF
}

function upload_support_sql_file () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")
  VAL_SUPPORT_SQL_REMOTE_FILE=$(mktemp --dry-run --suffix .sql)

  run_scp "${VAL_SUPPORT_SQL_LOCAL_FILE}" "${OPT_DROPLET_USER}@${address}:${VAL_SUPPORT_SQL_REMOTE_FILE}"
  rm -f "${VAL_SUPPORT_SQL_LOCAL_FILE}"
}

function remote_create_support_account () {
  debug "${FUNCNAME[0]}" "$@"

  load_remote_sql "${VAL_SUPPORT_SQL_REMOTE_FILE}"
}

function display_support_password () {
  debug "${FUNCNAME[0]}" "$@"

  echo "${VAL_SUPPORT_PASSWORD}"
}

function create_support_account () {
  debug "${FUNCNAME[0]}" "$@"

  if [[ -n "${OPT_CREATE_SUPPORT_ACCOUNT}" ]]; then
    generate_support_password
    create_support_sql_file
    upload_support_sql_file
    remote_create_support_account
    display_support_password
  fi

  exit 0
}

function remote_load_sql_file () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")
  local remote_file=$(mktemp --dry-run --suffix .sql)

  if [[ -n "${OPT_SQL_FILE}" && -f "${OPT_SQL_FILE}" && -n "${VAL_DROPLET_NAME}" ]]; then
    run_scp "${OPT_SQL_FILE}" "${OPT_DROPLET_USER}@${address}:${remote_file}"
    load_remote_sql "${remote_file}"
  fi

  exit 0
}

function power_on_droplet () {
  debug "${FUNCNAME[0]}" "$@"

  doadm -dn "${VAL_DROPLET_NAME}" --power-on

  exit $?
}

function power_off_droplet () {
  debug "${FUNCNAME[0]}" "$@"

  doadm -dn "${VAL_DROPLET_NAME}" --power-off

  exit $?
}

function restore_database () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")
  local remote_file="$(mktemp --dry-run --suffix .pg).xz"

  run_scp "${OPT_RESTORE_DATABASE}" "${OPT_DROPLET_USER}@${address}:${remote_file}"
  run_ssh "${OPT_DROPLET_USER}@${address}" "/usr/local/bin/pgadm --delete -If ${remote_file}"

  exit 0
}

function dump_database () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")
  local remote_file="$(mktemp --dry-run --suffix .pg).xz"

  run_ssh "${OPT_DROPLET_USER}@${address}" "/usr/local/bin/pgadm -Ef ${remote_file}"
  run_scp "${OPT_DROPLET_USER}@${address}:${remote_file}" "${OPT_DUMP_DATABASE}"
  run_ssh "${OPT_DROPLET_USER}@${address}" "rm -f ${remote_file}"

  exit 0
}

function restart_miki () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")

  run_ssh "${OPT_DROPLET_USER}@${address}" "systemctl restart miki.service"

  exit $?
}

function restart_machine () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")

  run_ssh "${OPT_DROPLET_USER}@${address}" "reboot"

  exit $?
}

function copy_file () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")

  if [[ -e "${OPT_ORIGIN_PATH}" && -n "${OPT_DESTINATION_PATH}" ]]; then
    run_rsync "${OPT_ORIGIN_PATH}" "${OPT_DROPLET_USER}@${address}:${OPT_DESTINATION_PATH}"
  fi

  exit $?
}

function _check_name () {
  debug "${FUNCNAME[0]}" "$@"

  doadm -ld | awk "/[0-9]+\s+miki/" | awk '{print $2}' | sed 's/^miki-//' | grep -q "^${OPT_NAME}$"

  return $?
}

function check_name () {
  debug "${FUNCNAME[0]}" "$@"

  if _check_name; then
    exit 1
  else
    exit 0
  fi
}

function garbage_collect () {
  debug "${FUNCNAME[0]}" "$@"

  rm -rf /tmp/tmp.*.miki
  rm -rf /tmp/yarn--*
  rm -rf /tmp/mkadm.*.log
  rm -rf /tmp/core-js-banners
  rm -rf /tmp/v8-compile-cache*
  rm -rf /tmp/tmp.*.miki-desktop
  rm -rf /tmp/tmp.*.sql

  exit 0
}

function rename_instance () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")

  run_ssh "${OPT_DROPLET_USER}@${address}" "hostnamectl set-hostname ${VAL_BASE_NAME}-${OPT_NEW_NAME}"
  doadm -rdn "${VAL_BASE_NAME}-${OPT_NAME}" -N "${VAL_BASE_NAME}-${OPT_NEW_NAME}"

  exit 0
}

function replace_instance () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")
  local tarball="/tmp/${OPT_REPLACE_TARBALL_BASE}"
  local date=$(date "+%Y%m%d%H%M%S")

  run_rsync "${OPT_REPLACE_TARBALL}" "${OPT_DROPLET_USER}@${address}:/tmp"
  run_ssh "${OPT_DROPLET_USER}@${address}" "systemctl stop miki.service"
  run_ssh "${OPT_DROPLET_USER}@${address}" "mv /var/miki /var/miki.${date}"
  run_ssh "${OPT_DROPLET_USER}@${address}" "tar -C /var -xJf ${tarball}; cp /var/miki.${date}/config.yml /var/miki"
  run_ssh "${OPT_DROPLET_USER}@${address}" "systemctl start miki.service"

  exit 0
}

function snapshot_instance () {
  debug "${FUNCNAME[0]}" "$@"

  local address=$(get_droplet_address "${VAL_DROPLET_NAME}")
  local date=$(date "+%Y%m%d%H%M%S")
  local tarball="${OPT_SNAPSHOT_TARBALL:-miki-${OPT_NAME}.${date}.tar.xz}"

  run_ssh "${OPT_DROPLET_USER}@${address}" "rm -rf /tmp/miki; cp -a /var/miki /tmp; rm -f /tmp/miki/config.yml"
  run_ssh "${OPT_DROPLET_USER}@${address}" "tar -C /tmp -cJf /tmp/miki.tar.xz miki"
  run_rsync "${OPT_DROPLET_USER}@${address}:/tmp/miki.tar.xz" "${tarball}"
  run_ssh "${OPT_DROPLET_USER}@${address}" "rm -rf /tmp/miki /tmp/miki.tar.xz"

  exit 0
}

function is_valid_desktop () {
  debug "${FUNCNAME[0]}" "$@"

  if [[ "${OPT_DESKTOP}" == "linux" || \
        "${OPT_DESKTOP}" == "windows" || \
        "${OPT_DESKTOP}" == "macos" ]]; then
    return 0
  else
    return 1
  fi
}

function extract_desktop () {
  debug "${FUNCNAME[0]}" "$@"

  OPT_MIKI_DESKTOP_DIRECTORY="$(mktemp -d --suffix .miki-desktop)"

  tar -C "${OPT_MIKI_DESKTOP_DIRECTORY}" -xJf "${VAL_MIKI_DESKTOP}"
  cp -a "${OPT_MIKI_DIRECTORY}" "${OPT_MIKI_DESKTOP_DIRECTORY}/miki-desktop/app"
  push "${OPT_MIKI_DESKTOP_DIRECTORY}/miki-desktop"
}

function delete_modules () {
  debug "${FUNCNAME[0]}" "$@"

  rm -rf app/miki/node_modules
  rm -rf node_modules
}

function install_modules () {
  debug "${FUNCNAME[0]}" "$@"

  if [[ -n "${OPT_DESKTOP}" ]]; then
    case "${OPT_DESKTOP}" in
      linux)
        tar -C app/miki -xJf "${VAL_MODULES_LINUX_MIKI}"
        tar -xf "${VAL_MODULES_LINUX_MIKI_DESKTOP}"
      ;;
      windows)
        tar -C app/miki -xJf "${VAL_MODULES_WINDOWS_MIKI}"
        tar -xf "${VAL_MODULES_WINDOWS_MIKI_DESKTOP}"
        ;;
      macos)
        tar -C app/miki -xJf "${VAL_MODULES_MACOS_MIKI}"
        tar -xf "${VAL_MODULES_MACOS_MIKI_DESKTOP}"
        ;;
      *)
        error "ERROR: The specified platform does not exist. Aborting."
        ;;
    esac
  fi
}

function install_sqlite () {
  debug "${FUNCNAME[0]}" "$@"

  unxz -c "${OPT_SQLITE_DATABASE_INIT}" > app/miki/db/db.sqlite
}

function load_sqlite_file () {
  debug "${FUNCNAME[0]}" "$@"

  local source_file="${1}"
  local dest_file="${2}"

  cat "${source_file}" | sqlite3 "${dest_file}"
}

function create_sqlite_admin_sql_file () {
  debug "${FUNCNAME[0]}" "$@"

  local id=1
  local date=$(generate_date)

  VAL_ADMIN_SQL_LOCAL_FILE=$(mktemp --suffix .sql)

  cat << EOF > ${VAL_ADMIN_SQL_LOCAL_FILE}
UPDATE users SET email = '${OPT_EMAIL}' WHERE id = '${id}';
UPDATE users SET password = '${VAL_ADMIN_PASSWORD_HASH}' WHERE id = '${id}';
UPDATE users SET "mustChangePwd" = 't' WHERE id = '${id}';
UPDATE settings SET value = '{"v":"https://${VAL_DOMAIN_NAME}"}' WHERE key = 'host';
EOF
}

function load_sqlite_admin_sql_file () {
  debug "${FUNCNAME[0]}" "$@"

  load_sqlite_file "${VAL_ADMIN_SQL_LOCAL_FILE}" app/miki/db/db.sqlite
}

function delete_sqlite_admin_sql_file () {
  debug "${FUNCNAME[0]}" "$@"

  [[ -f "${VAL_ADMIN_SQL_LOCAL_FILE}" ]] && rm -f "${VAL_ADMIN_SQL_LOCAL_FILE}"
}

function reset_sqlite_admin_password () {
  debug "${FUNCNAME[0]}" "$@"

  if [[ -n "${OPT_DESKTOP}" && -n "${OPT_EMAIL}" ]]; then
    generate_admin_password
    create_sqlite_admin_sql_file
    load_sqlite_admin_sql_file
    delete_sqlite_admin_sql_file
  fi
}

function package_desktop () {
  debug "${FUNCNAME[0]}" "$@"

  local icons="assets/icons/icon.icns"

  case "${OPT_DESKTOP}" in
    linux)
      electron-packager . --platform=linux --out=out --icon="${icons}" --overwrite
      ;;
    windows)
      electron-packager . --platform=win32 --out=out --icon="${icons}" --overwrite
      ;;
    macos)
      electron-packager . --platform=darwin --out=out --icon="${icons}" --overwrite
      ;;
    *)
      error "ERROR: The specified platform is not supported. Aborting."
      ;;
  esac
}

function build_desktop () {
  debug "${FUNCNAME[0]}" "$@"

  case "${OPT_DESKTOP}" in
    linux)
      electron-builder --linux --prepackaged "out/Miki Desktop-linux-x64"
      ;;
    windows)
      electron-builder --windows --prepackaged "out/Miki Desktop-win32-x64"
      ;;
    *)
      error "ERROR: The specified platform is not supported. Aborting."
      ;;
  esac
}

function upload_file () {
  debug "${FUNCNAME[0]}" "$@"

  local file="$1"
  local name="$2"

  s3cmd -P --expiry-days "${VAL_SPACES_EXPIRY}" \
        put "${file}" "${OPT_SPACES_BUCKET}/${name}"
}

function upload_desktop () {
  debug "${FUNCNAME[0]}" "$@"

  local date=$(date +"%Y%m%dT%H%M%S")
  local prefix="${date}.${OPT_SUBSCRIPTION_ID}"

  case "${OPT_DESKTOP}" in
    linux)
      upload_file out/*.AppImage "${prefix}.miki-desktop.AppImage"
      OPT_DESKTOP_URL="${OPT_SPACES_URL}/${prefix}.miki-desktop.AppImage"
      ;;
    windows)
      upload_file out/*.exe "${prefix}.miki-desktop.exe"
      OPT_DESKTOP_URL="${OPT_SPACES_URL}/${prefix}.miki-desktop.exe"
      ;;
    macos)
      true
      ;;
    *)
      error "ERROR: The specified platform is not supported. Aborting."
      ;;
  esac
}

function delete_miki_desktop_directory () {
  debug "${FUNCNAME[0]}" "$@"

  [[ -d "${OPT_MIKI_DESKTOP_DIRECTORY}" ]] && rm -rf "${OPT_MIKI_DESKTOP_DIRECTORY}"
}

function desktop_display_greeting () {
  debug "${FUNCNAME[0]}" "$@"

  echo "================================================================================"
  echo " Your new Miki Desktop instance is now ready."
  echo ""
  echo " Name: ${OPT_NAME}"
  echo " URL: ${OPT_DESKTOP_URL}"
  echo " Username: ${OPT_EMAIL}"
  echo " Password: ${VAL_ADMIN_PASSWORD}"
  echo "================================================================================"
}

function desktop_install () {
  debug "${FUNCNAME[0]}" "$@"

  extract_desktop
  delete_modules
  install_modules
  install_sqlite
  reset_sqlite_admin_password
  package_desktop
  build_desktop
  upload_desktop
  delete_miki_desktop_directory
  desktop_display_greeting
  notify_hook

  exit 0
}

function dispatch_install () {
  debug "${FUNCNAME[0]}" "$@"

  if [[ -n "${OPT_EMAIL}" && -n "${OPT_DESKTOP}" ]] && is_valid_desktop; then
    desktop_install
  elif [[ -n "${OPT_EMAIL}" && -z "${OPT_DESKTOP}" && -n "${OPT_INSTALL_PATH}" && \
          -n "${OPT_DATABASE_NAME}" && -n "${OPT_DATABASE_USER}" ]]; then
    remote_install
  else
    error "ERROR: Installation type not found. Aborting."
  fi
}


function main () {
  debug "${FUNCNAME[0]}" "$@"

  parse_arguments "$@"
  set_component_names
  process_arguments "$@"

  local_build
  dispatch_install
}

main "$@"
