#!/usr/bin/env bash

set -euo pipefail

readonly SELF="$(basename ${BASH_SOURCE[0]})"
readonly SELF_DIR="$(cd $(dirname $(readlink -f ${BASH_SOURCE[0]})) > /dev/null 2>&1 && pwd)"
readonly OS="$(uname)"
readonly VERSION="1.4.5"

OPT_HELP=
OPT_DEBUG=
OPT_VERBOSE=
OPT_VERSION=

readonly VAL_BASE_NAME="miki"
readonly VAL_WWW_NAME="www"
readonly VAL_FW_NAME="fw"
readonly VAL_SLEEP="15"
readonly VAL_RANDOM="$(od -t uI -N 4 /dev/urandom | awk '{print $2}' | sed 2d)"
readonly VAL_BASE_COMMIT="2.5.159"
readonly VAL_DEFAULT_PACKAGE_VERSION="1.0.0"
readonly VAL_MIKI_DOMAIN="miki.mimix.io"
readonly VAL_RESOURCES_DIR="${SELF_DIR}/resources"
readonly VAL_DEFAULT_DOMAIN="streamsharing.io"
readonly VAL_REMOTE_BIN="/usr/local/bin"
readonly VAL_REMOTE_TMP="/tmp"
readonly VAL_MIKI_REPOSITORY="https://github.com/themimixcompany/wiki"

VAL_DOMAIN=
VAL_DROPLET=
VAL_FIREWALL=
VAL_PASSWORD_FILE=

OPT_RESET_ADMIN_PASSWORD=
VAL_ADMIN_PASSWORD=
VAL_ADMIN_PASSWORD_HASH=
VAL_ADMIN_SQL_LOCAL_FILE=
VAL_ADMIN_SQL_REMOTE_FILE=

OPT_CREATE_SUPPORT_ACCOUNT=
VAL_SUPPORT_PASSWORD=
VAL_SUPPORT_PASSWORD_HASH=
VAL_SUPPORT_SQL_LOCAL_FILE=
VAL_SUPPORT_SQL_REMOTE_FILE=

OPT_NAME=
OPT_MIKI_DIRECTORY=
OPT_WIKI_NAME="miki"
OPT_WIKI_DOMAIN=
OPT_WIKI_RESOURCES="/_assets/svg"
OPT_COMPANY_NAME="miki"
OPT_COMPANY_DOMAIN="mimix.io"
OPT_PACKAGE_VERSION=
OPT_ENABLE_WIKI_SSL="false"
OPT_ENABLE_DB_SSL="false"
OPT_PGADM_PATH="$(which pgadm)"
OPT_PGSQL_PATH="$(which pgsql)"
OPT_INSTALL_PATH="/var/miki"
OPT_INSTALL_REMOTELY=
OPT_REMOVE_SELF_SSH_KEY=
OPT_SSH_KEYS=
OPT_DROPLET_USER="root"
OPT_DROPLET_NAME=
OPT_DROPLET_ADDRESS=
OPT_DATABASE_NAME="defaultdb"
OPT_DATABASE_USER="doadmin"
OPT_DATABASE_INIT=
OPT_FIREWALL_NAME=
OPT_FIREWALL_ADDRESSES=
OPT_FIREWALL_PORTS="22,80,443"
OPT_CREATE_FIREWALL=
OPT_HOST=
OPT_SEND_FILTER=
OPT_YAML_FILTER=
OPT_ENABLE_SSL=
OPT_DISABLE_SSL=
OPT_DOMAIN_NAME=
OPT_SSH=
OPT_COMMAND=
OPT_SQL=
OPT_SQL_FILE=
OPT_EXPUNGE_INSTANCE=
OPT_LIST_INSTANCES=
OPT_POWER_ON=
OPT_POWER_OFF=
OPT_IMPORT_DUMP=
OPT_EXPORT_DUMP=
OPT_RESTART_MIKI=
OPT_RESTART_MACHINE=

function error () {
  if [[ "${OS}" == "Darwin" ]]; then
    echo "ERROR: ${@}" >&2
  else
    echo -e "\e[0;31m\e[1mERROR: \e[0;0m${@}" >&2
  fi

  exit 1
}

function warn () {
  if [[ "${OS}" == "Darwin" ]]; then
    echo "WARNING: ${@}" >&2
  else
    echo -e "\e[0;33mWARNING: \e[0;0m${@}" >&2
  fi
}

function debug () {
  if [[ -n "${OPT_DEBUG}" ]]; then
    echo -n "** "
    echo "\${PWD}: ${PWD}"
    echo "\${@}: ${@}"
  fi
}

function push () {
  debug ${FUNCNAME[0]} "$@"

  pushd "${1}" &> /dev/null
}

function pop () {
  debug ${FUNCNAME[0]} "$@"

  popd &> /dev/null
}

function run_ssh () {
  debug ${FUNCNAME[0]} "$@"

  ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o LogLevel=ERROR "$@"
}

function run_scp () {
  debug ${FUNCNAME[0]} "$@"

  scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o LogLevel=ERROR "$@"
}

function parse_arguments () {
  debug ${FUNCNAME[0]} "$@"

  local opts=$(getopt -n "${SELF}" --options n:V:eEp:P:iKk:D:B:U:I:F:A:P:fH:Y:lsc:QS:xrtoO --longoptions help,debug,verbose,version,name:,wiki-name:,wiki-domain:,wiki-resources:,company-name:,company-domain:,package-version:,enable-wiki-ssl,enable-db-ssl,pgadm-path:,install-path:,install-remotely,remove-self-ssh-key,ssh-keys:,droplet-name:,database-name:,database-user:,database-init:,firewall-name:,add-self-address,firewall-addresses:,firewall-ports:,create-firewall,host:,yaml-filter:,enable-ssl,disable-ssl,domain-name:,list-instances,command:,ssh,sql,sql-file:,expunge-instance,reset-admin-password,create-support-account,power-on,power-off,import-dump:,export-dump:,restart-miki,restart-machine -- "$@")

  if [[ $? != 0 ]]; then
    error "Failed to parse arguments. Aborting."
  fi

  eval set -- "${opts}"

  while true; do
    case "$1" in
      (--help) OPT_HELP=true; shift ;;
      (--debug) OPT_DEBUG=true; shift ;;
      (--verbose) OPT_VERBOSE=true; shift ;;
      (--version) OPT_VERSION=true; shift ;;
      (-n|--name) OPT_NAME=$2; shift 2 ;;
      (--wiki-name) OPT_WIKI_NAME=$2; shift 2 ;;
      (--wiki-domain) OPT_WIKI_DOMAIN=$2; shift 2 ;;
      (--wiki-resources) OPT_WIKI_RESOURCES=$2; shift 2 ;;
      (--company-name) OPT_COMPANY_NAME=$2; shift 2 ;;
      (--company-domain) OPT_COMPANY_DOMAIN=$2; shift 2 ;;
      (-V|--package-version) OPT_PACKAGE_VERSION=$2; shift 2 ;;
      (-e|--enable-wiki-ssl) OPT_ENABLE_WIKI_SSL=true; shift ;;
      (-E|--enable-db-ssl) OPT_ENABLE_DB_SSL=true; shift ;;
      (-p|--pgadm-path) OPT_PGADM_PATH=$2; shift 2 ;;
      (-P|--install-path) OPT_MAKE_TARBALL=true; OPT_INSTALL_PATH=$2; shift 2 ;;
      (-i|--install-remotely) OPT_MAKE_TARBALL=true; OPT_INSTALL_REMOTELY=true; shift ;;
      (-K|--remove-self-ssh-key) OPT_REMOVE_SELF_SSH_KEY=true; shift ;;
      (-k|--ssh-keys) OPT_SSH_KEYS=$2; shift 2 ;;
      (-D|--droplet-name) OPT_DROPLET_NAME=$2; shift 2 ;;
      (-B|--database-name) OPT_DATABASE_NAME=$2; shift 2 ;;
      (-U|--database-user) OPT_DATABASE_USER=$2; shift 2 ;;
      (-I|--database-init) OPT_DATABASE_INIT=$2; shift 2 ;;
      (-F|--firewall-name) OPT_FIREWALL_NAME=$2; shift 2 ;;
      (-A|--firewall-addresses) OPT_FIREWALL_ADDRESSES=$2; shift 2 ;;
      (-P|--firewall-ports) OPT_FIREWALL_PORTS=$2; shift 2 ;;
      (-f|--create-firewall) OPT_CREATE_FIREWALL=true; shift ;;
      (-H|--host) OPT_HOST=$2; shift 2 ;;
      (-Y|--yaml-filter) OPT_SEND_FILTER=true; OPT_YAML_FILTER=$2; shift 2 ;;
      (--enable-ssl) OPT_SEND_FILTER=true; OPT_ENABLE_SSL=true; shift ;;
      (--disable-ssl) OPT_SEND_FILTER=true; OPT_DISABLE_SSL=true; shift ;;
      (--domain-name) OPT_SEND_FILTER=true; OPT_DOMAIN_NAME=$2; shift 2 ;;
      (-l|--list-instances) OPT_LIST_INSTANCES=true; shift ;;
      (-s|--ssh) OPT_SSH=true; shift ;;
      (-c|--command) OPT_COMMAND=$2; shift 2 ;;
      (-Q|--sql) OPT_SQL=true; shift ;;
      (-S|--sql-file) OPT_SQL_FILE=$2; shift 2 ;;
      (-x|--expunge) OPT_EXPUNGE_INSTANCE=true; shift ;;
      (-r|--reset-admin-password) OPT_RESET_ADMIN_PASSWORD=true; shift ;;
      (-t|--create-support-account) OPT_CREATE_SUPPORT_ACCOUNT=true; shift ;;
      (-o|--power-on) OPT_POWER_ON=true; shift ;;
      (-O|--power-off) OPT_POWER_OFF=true; shift ;;
      (--import-dump) OPT_IMPORT_DUMP=$2; shift 2 ;;
      (--export-dump) OPT_EXPORT_DUMP=$2; shift 2 ;;
      (--restart-miki) OPT_RESTART_MIKI=true; shift ;;
      (--restart-machine) OPT_RESTART_MACHINE=true; shift ;;
      (--) shift; break ;;
      (*) break ;;
    esac
  done
}

function get_droplet_id () {
  debug ${FUNCNAME[0]} "$@"

  doadm -LD | awk "/[0-9]+\s+${1}\s+/" | awk '{print $1}'
}

function get_droplet_name () {
  debug ${FUNCNAME[0]} "$@"

  doadm -LD | awk "/[0-9]+\s+${1}\s+/" | awk '{print $2}'
}

function get_droplet_address () {
  debug ${FUNCNAME[0]} "$@"

  doadm -LD | awk "/[0-9]+\s+${1}\s+/" | awk '{print $3}'
}

function make_miki_www_name () {
  debug ${FUNCNAME[0]} "$@"

  echo "${VAL_BASE_NAME}-${OPT_NAME}"
}

function make_miki_fw_name () {
  debug ${FUNCNAME[0]} "$@"

  echo "${VAL_BASE_NAME}-${OPT_NAME}-${VAL_FW_NAME}"
}

function set_name () {
  debug ${FUNCNAME[0]} "$@"

  OPT_HOST=$(make_miki_www_name)
}

function set_domain_name () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_WIKI_DOMAIN}" ]]; then
    VAL_DOMAIN="${OPT_WIKI_DOMAIN}"
  elif [[ -n "${OPT_NAME}" ]]; then
    VAL_DOMAIN="${OPT_NAME}.${VAL_DEFAULT_DOMAIN}"
  else
    VAL_DOMAIN="${VAL_MIKI_DOMAIN}"
  fi
}

function set_droplet_name () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_DROPLET_NAME}" ]]; then
    VAL_DROPLET="${OPT_DROPLET_NAME}"
  elif [[ -n "${OPT_NAME}" ]]; then
    VAL_DROPLET="$(make_miki_www_name)"
  else
    VAL_DROPLET=
  fi
}

function set_firewall_name () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_FIREWALL_NAME}" ]]; then
    VAL_FIREWALL="${OPT_FIREWALL_NAME}"
  elif [[ -n "${OPT_NAME}" && -n "${OPT_CREATE_FIREWALL}" ]]; then
    VAL_FIREWALL="$(make_miki_fw_name)"
  else
    VAL_FIREWALL=
  fi
}

function set_names () {
  debug ${FUNCNAME[0]} "$@"

  set_domain_name
  set_droplet_name
  set_firewall_name
}

function process_arguments () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_HELP}" || "${#}" -lt 1 ]]; then
    display_usage
  elif [[ -n "${OPT_VERSION}" ]]; then
    display_version
  elif [[ -n "${OPT_IMPORT_DUMP}" ]]; then
    set_name
    import_dump
  elif [[ -n "${OPT_EXPORT_DUMP}" ]]; then
    set_name
    export_dump
  elif [[ -n "${OPT_RESET_ADMIN_PASSWORD}" ]]; then
    set_name
    reset_admin_password
  elif [[ -n "${OPT_CREATE_SUPPORT_ACCOUNT}" ]]; then
    set_name
    create_support_account
  elif [[ -n "${OPT_INSTALL_REMOTELY}" ]]; then
    check_droplet
  elif [[ -n "${OPT_LIST_INSTANCES}" ]]; then
    list_instances
  elif [[ -n "${OPT_SSH}" && -n "${OPT_NAME}" ]]; then
    set_name
    connect_ssh
  elif [[ -n "${OPT_SQL}" && -n "${OPT_NAME}" ]]; then
    set_name
    connect_sql
  elif [[ -n "${OPT_SQL_FILE}" && -n "${OPT_NAME}" ]]; then
    set_name
    remote_load_sql_file
  elif [[ -n "${OPT_COMMAND}" && -n "${OPT_NAME}" ]]; then
    set_name
    send_command
  elif [[ -n "${OPT_EXPUNGE_INSTANCE}" && -n "${OPT_NAME}" ]]; then
    set_name
    expunge_instance
  elif [[ -n "${OPT_NAME}" && -n "${OPT_SEND_FILTER}" ]]; then
    set_name
    send_filter
  elif [[ -n "${OPT_POWER_ON}" ]]; then
    set_name
    power_on_droplet
  elif [[ -n "${OPT_POWER_OFF}" ]]; then
    set_name
    power_off_droplet
  elif [[ -n "${OPT_RESTART_MIKI}" ]]; then
    set_name
    restart_miki
  elif [[ -n "${OPT_RESTART_MACHINE}" ]]; then
    set_name
    restart_machine
  elif [[ ! "$(basename ${OPT_MIKI_DIRECTORY})" == "miki" ]]; then
    display_usage
  elif [[ -z "${OPT_WIKI_NAME}" || -z "${OPT_WIKI_RESOURCES}" || -z "${OPT_COMPANY_NAME}" || -z "${OPT_COMPANY_DOMAIN}" ]]; then
    display_usage
  else
    return 0
  fi
}

function display_usage () {
  debug ${FUNCNAME[0]} "$@"

  cat << EOF
${SELF} v${VERSION} [OPTIONS]...

OPTIONS:
      --help                    Show this help
      --debug                   Enable debugging mode
      --verbose                 Enable verbose output
      --version                 Display program version info
  -n, --name                    Set the name of the instance
  -w, --wiki-name               Set wiki name
  -d, --wiki-domain             Set wiki domain
  -R, --wiki-resources          Set path of wiki resources
      --company-name            Set company name
      --company-domain          Set company domain
  -V, --package-version         Set version in package.json
  -e, --enable-wiki-ssl         Enable wiki config SSL
  -E, --enable-db-ssl           Enable database config SSL
  -p, --pgadm-path              Specify the path of the pgadm program
  -P, --install-path            Specify the installation path of Miki on the instance
  -i, --install-remotely        Flag to perform remote installation
  -K, --remove-self-ssh-key     Remove the SSH key of the host from the allowed SSH keys
  -k, --ssh-keys                Comma-separated list of allowed SSH keys on the instance
  -D, --droplet-name            Set the name of droplet to manage
  -B, --database-name           Set the name of the database
  -U, --database-user           Set the name of the database user
  -I, --database-init           Initialize the database with a dump
  -F, --firewall-name           Set the name of firewall for this droplet
  -A, --firewall-addresses      Comma-separated list of IP addresses to allow on the droplet
  -P, --firewall-ports          Comma-separated list of allowed ports on the droplet
  -f, --create-firewall         Create a firewall based from the instance name
  -H, --host                    Override the name of the remote host
  -Y, --yaml-filter             Send a YAML filter to an address
      --enable-ssl              Enable SSL on the remote instance
      --disable-ssl             Disable SSL on the remote instance
      --domain-name             Set the domain name of the remote instance
  -l, --list-instances          List all instances
  -s, --ssh                     Connect to the instance via SSH
  -c, --command                 Run an arbitrary command to the instance
  -Q, --sql                     Connect to the SQL prompt of the instance
  -S, --sql-file                Specify the SQL file to upload to the instance
  -x, --expunge-instance        Expunge the instance
  -r, --reset-admin-password    Reset the admin password of the instance
  -t, --create-support-account  Create a support account on the instance
  -o, --power-on                Turn on the droplet
  -O, --power-off               Turn off the droplet
      --import-dump             Import a database dump into the instance
      --export-dump             Export the database dump from the instance
EOF
  exit 0
}

function display_version () {
  debug ${FUNCNAME[0]} "$@"

  cat << EOF
${SELF} v${VERSION}
EOF
  exit 0
}

function create_miki_directory () {
  debug ${FUNCNAME[0]} "$@"

  OPT_MIKI_DIRECTORY="$(mktemp -d --suffix .miki)/miki"
}

function clone_repository () {
  debug ${FUNCNAME[0]} "$@"

  git clone "${VAL_MIKI_REPOSITORY}" "${OPT_MIKI_DIRECTORY}"
}

function delete_miki_directory () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -d "${OPT_MIKI_DIRECTORY}" ]]; then
    rm -rf "${OPT_MIKI_DIRECTORY}"
  fi
}

function initialize () {
  debug ${FUNCNAME[0]} "$@"

  display_banner "Performing initialization ..."

  create_miki_directory
  clone_repository
  push "${OPT_MIKI_DIRECTORY}"

  if [[ -f "package.json" && "$(jq -r '.name' package.json)" == "wiki" ]]; then
    return 0
  else
    error "The current directory does not contain the correct contents. Aborting."
  fi
}

function reset_repository () {
  debug ${FUNCNAME[0]} "$@"

  git reset --hard "${VAL_BASE_COMMIT}" &> /dev/null
}

function npm_install () {
  debug ${FUNCNAME[0]} "$@"

  npm install
}

function delete_files () {
  debug ${FUNCNAME[0]} "$@"

  rm -rf db
  rm -rf data
}

function create_readme () {
  debug ${FUNCNAME[0]} "$@"

  cat << EOF > README.md
# miki
EOF
}

function create_local_config_yml () {
  debug ${FUNCNAME[0]} "$@"

  cat << EOF > config.yml
port: 3000

db:
  type: sqlite
  storage: db/db.sqlite

ssl:
  enabled: false

bindIP: 0.0.0.0

logLevel: info

offline: false

ha: false

dataPath: ./data
EOF
}

function find_id () {
  debug ${FUNCNAME[0]} "$@"

  local path=$1
  local regex=$2

  find ${path} -name "${regex}" | awk -F \. '{print $2}'
}

function copy_vue_files () {
  debug ${FUNCNAME[0]} "$@"

  rsync -a "${VAL_RESOURCES_DIR}/client" .
}

function update_files () {
  debug ${FUNCNAME[0]} "$@"

  declare -A SUBSTITUTIONS=(
    ['wikijs-butterfly.svg']="${OPT_COMPANY_NAME}.svg"

    ['wiki\.js']="${OPT_WIKI_NAME,,}"
    ['wiki-js']="${OPT_WIKI_NAME,,}"
    ['wikijs']="${OPT_WIKI_NAME,,}"
    ['Wiki\.js']="${OPT_WIKI_NAME^}"
    ['WIKI\.js']="${OPT_WIKI_NAME^}"

    #['wiki\.js\.org']="${VAL_DOMAIN}"
    ['wiki\.js\.org']="${VAL_MIKI_DOMAIN}"

    ['wiki\.yourdomain\.com']="${VAL_DOMAIN}"

    ['https://static\.requarks\.io/logo']="${OPT_WIKI_RESOURCES}"

    ['https://github\.com/Requarks/wiki']="https://github.com/themimixcompany/miki"

    #['requarks\.io']="${OPT_COMPANY_DOMAIN}"
    #['requarks']="${OPT_COMPANY_NAME}"
    #['Requarks']="${OPT_COMPANY_NAME^}"
  )

  for i in "${!SUBSTITUTIONS[@]}"; do
    for file in $(rg -l "$i"); do
      sed -i -e "s|${i}|${SUBSTITUTIONS[$i]}|g" "$file"
    done
  done
}

function update_package_json () {
  debug ${FUNCNAME[0]} "$@"

  local temp=$(mktemp)
  local version=${OPT_PACKAGE_VERSION:-${VAL_DEFAULT_PACKAGE_VERSION}}

  cat package.json | jq ".version = \"${version}\""  | jq '.dev = false' > "${temp}"
  mv -f ${temp} package.json
}

function display_banner () {
  local message="${1}"

  echo "================================================================================"
  echo " ${message}"
  echo "================================================================================"

}

function yarn_build () {
  debug ${FUNCNAME[0]} "$@"

  display_banner "Compiling sources ..."
  yarn build
}

function install_assets () {
  debug ${FUNCNAME[0]} "$@"

  rsync -a ${VAL_RESOURCES_DIR}/assets/favicon.ico assets
  rsync -a ${VAL_RESOURCES_DIR}/assets/favicons assets
  rsync -a ${VAL_RESOURCES_DIR}/assets/svg assets
  rsync -a ${VAL_RESOURCES_DIR}/assets/img/splash assets/img
}

function create_db_directory () {
  debug ${FUNCNAME[0]} "$@"

  mkdir -p db
}

function create_password () {
  debug ${FUNCNAME[0]} "$@"

  < /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c ${1:-32}
}

function create_password_file () {
  debug ${FUNCNAME[0]} "$@"

  VAL_PASSWORD_FILE=$(mktemp)

  echo $(create_password) > "${VAL_PASSWORD_FILE}"
}

function create_remote_config_yml () {
  debug ${FUNCNAME[0]} "$@"

  cat << EOF > config.yml
#port: 3000

db:
  type: postgres
  host: localhost
  port: 5432
  user: ${OPT_DATABASE_USER}
  pass: $(cat ${VAL_PASSWORD_FILE})
  db: ${OPT_DATABASE_NAME}
  ssl: ${OPT_ENABLE_DB_SSL}
  sslOptions:
    auto: true
    ca: ./keys/ca.crt
    cert: ./keys/cert.pem
    key: ./keys/key.pem

ssl:
  enabled: ${OPT_ENABLE_WIKI_SSL}
  port: 443
  provider: letsencrypt
  domain: ${VAL_DOMAIN}
  subscriberEmail: david@mimix.io

bindIP: 0.0.0.0

logLevel: info

offline: false

ha: false

dataPath: ./data
EOF
}

function delete_password_file () {
  debug ${FUNCNAME[0]} "$@"

  rm -f "${VAL_PASSWORD_FILE}"
}

function create_init_sql () {
  debug ${FUNCNAME[0]} "$@"

  mkdir -p sql
  cat << EOF > sql/init.sql
CREATE database ${OPT_DATABASE_NAME};
CREATE user ${OPT_DATABASE_USER} password '$(cat ${VAL_PASSWORD_FILE})';
GRANT ALL PRIVILEGES ON DATABASE ${OPT_DATABASE_NAME} TO ${OPT_DATABASE_USER};
EOF
}

function create_post_sql () {
  debug ${FUNCNAME[0]} "$@"

  mkdir -p sql
  cat << EOF > sql/post.sql
UPDATE "searchEngines" SET db = 'f' WHERE key = db;
UPDATE "searchEngines" SET postgres = 't' WHERE key = postgres;
EOF
}

function copy_bin () {
  debug ${FUNCNAME[0]} "$@"

  rm -rf bin
  rsync -aL "${SELF_DIR}/bin" .
}

function create_tarball () {
  debug ${FUNCNAME[0]} "$@"

  local file=$(basename ${OPT_MIKI_DIRECTORY}).tar.gz

  pop

  if [[ -d "${OPT_MIKI_DIRECTORY}" ]]; then
    tar -C "$(dirname ${OPT_MIKI_DIRECTORY})" \
        -czf "${file}" --exclude ".git" \
        "$(basename ${OPT_MIKI_DIRECTORY})"
    if [[ -z "${OPT_INSTALL_REMOTELY}" ]]; then
      delete_miki_directory
    else
      return 0
    fi
  else
    error "Cannot create a tarball. Aborting."
  fi
}

function self_ssh_key () {
  debug ${FUNCNAME[0]} "$@"

  local key_file=

  if [[ -n "$HOME/.ssh/id_ed25519" ]]; then
    key_file="$HOME/.ssh/id_ed25519"
  elif [[ -n "$HOME/.ssh/id_rsa" ]]; then
    key_file="$HOME/.ssh/id_rsa"
  fi

  if [[ -n "${key_file}" ]]; then
    ssh-keygen -l -E md5 -f "${key_file}" | awk '{print $2}' | sed 's/^...://'
  fi
}

function set_ssh_keys () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -z "${OPT_REMOVE_SELF_SSH_KEY}" ]]; then
    if [[ -n "${OPT_SSH_KEYS}" ]]; then
      OPT_SSH_KEYS="${OPT_SSH_KEYS},$(self_ssh_key)"
    else
      OPT_SSH_KEYS="$(self_ssh_key)"
    fi
  else
    OPT_SSH_KEYS="${OPT_SSH_KEYS}"
  fi
}

function create_droplet () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_INSTALL_PATH}" && -n "${VAL_DROPLET}" ]]; then
    OPT_DROPLET_ADDRESS=$(doadm -CDN "${VAL_DROPLET}" -K "${OPT_SSH_KEYS}" )
    echo "${OPT_DROPLET_ADDRESS}"
  fi
}

function droplet_ready_p () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${VAL_DROPLET}" && -n "${OPT_DROPLET_ADDRESS}" ]]; then
    return 0
  else
    return 1
  fi
}

function upload_tarball () {
  debug ${FUNCNAME[0]} "$@"

  local file="$(basename ${OPT_MIKI_DIRECTORY}).tar.gz"

  sleep "${VAL_SLEEP}"

  if [[ -f "${file}" && -n "${OPT_INSTALL_PATH}" && -n "${OPT_DROPLET_USER}" ]] && droplet_ready_p; then
    run_scp "${file}" "${OPT_DROPLET_USER}@${OPT_DROPLET_ADDRESS}:"
  fi
}

function delete_tarball () {
  debug ${FUNCNAME[0]} "$@"

  local directory="$(dirname ${OPT_MIKI_DIRECTORY})"
  local file="$(basename ${OPT_MIKI_DIRECTORY}).tar.gz"
}

function upload_database_init () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_DATABASE_INIT}" ]]; then
    run_scp "${OPT_DATABASE_INIT}" "${OPT_DROPLET_USER}@${OPT_DROPLET_ADDRESS}:${VAL_REMOTE_TMP}"
  fi
}

function upload_pgadm () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_INSTALL_PATH}" ]] && droplet_ready_p; then
    run_scp "${OPT_PGADM_PATH}" "${OPT_DROPLET_USER}@${OPT_DROPLET_ADDRESS}:${VAL_REMOTE_BIN}"
  fi
}

function upload_pgsql () {
  if [[ -n "${OPT_INSTALL_PATH}" ]] && droplet_ready_p; then
    run_scp "${OPT_PGSQL_PATH}" "${OPT_DROPLET_USER}@${OPT_DROPLET_ADDRESS}:${VAL_REMOTE_BIN}"
  fi
}

function install_miki () {
  debug ${FUNCNAME[0]} "$@"

  local file="$(basename ${OPT_MIKI_DIRECTORY}).tar.gz"
  local base_cmd="tar -C /var -xf ${file}; bash ${OPT_INSTALL_PATH}/bin/install -i ${OPT_INSTALL_PATH}"
  local cmd=

  if [[ -n "${OPT_INSTALL_PATH}" ]] && droplet_ready_p && [[ -n "${OPT_DATABASE_INIT}" ]]; then
    cmd="${base_cmd} -I ${VAL_REMOTE_TMP}/$(basename ${OPT_DATABASE_INIT})"
  else
    cmd="${base_cmd}"
  fi

  if [[ -n "${OPT_INSTALL_PATH}" ]] && droplet_ready_p; then
    run_ssh "${OPT_DROPLET_USER}@${OPT_DROPLET_ADDRESS}" "${cmd}"
  fi

  return 0
}

function create_firewall () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${VAL_FIREWALL}" ]]; then
    doadm -CFN "${VAL_FIREWALL}" -a "${VAL_DROPLET}" \
          -SA "${OPT_FIREWALL_ADDRESSES}" -P "${OPT_FIREWALL_PORTS}"
  fi
}

function display_address () {
  debug ${FUNCNAME[0]} "$@"

  display_banner "Your new Miki instance is now available at http://${OPT_DROPLET_ADDRESS}."
}

function local_install_p () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -z "${OPT_INSTALL_REMOTELY}" ]]; then
    return 0
  else
    return 1
  fi
}

function local_install () {
  debug ${FUNCNAME[0]} "$@"

  initialize
  reset_repository
  npm_install
  delete_files
  create_readme
  create_local_config_yml

  copy_vue_files
  update_files
  update_package_json
  yarn_build

  install_assets
  create_db_directory

  create_tarball
}

function check_droplet () {
  debug ${FUNCNAME[0]} "$@"

  local droplet=$(get_droplet_name ${VAL_DROPLET})

  if [[ -n "${droplet}" ]]; then
    error "A droplet with that name already exists. Aborting."
  else
    return 0
  fi
}

function remote_install () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_INSTALL_REMOTELY}" && -n "${OPT_INSTALL_PATH}" && \
          -n "${OPT_DATABASE_NAME}" && -n "${OPT_DATABASE_USER}" ]]; then
    push "${OPT_MIKI_DIRECTORY}"

    create_password_file
    create_remote_config_yml
    create_init_sql
    #create_post_sql
    delete_password_file
    copy_bin

    create_tarball
    delete_miki_directory

    set_ssh_keys
    create_droplet
    upload_tarball
    delete_tarball

    upload_database_init
    upload_pgadm
    upload_pgsql

    install_miki
    create_firewall
    display_address
  fi
}

function send_yaml_filter () {
  debug ${FUNCNAME[0]} "$@"

  local filter="${1:-${OPT_YAML_FILTER}}"

  if [[ -n "${filter}" && -n "${OPT_HOST}" ]]; then
    for address in $(get_droplet_address "${OPT_HOST}"); do
      run_ssh "${OPT_DROPLET_USER}@${address}" \
              "yq -iy \"${filter}\" /var/miki/config.yml; systemctl restart miki.service"
    done
  fi
}

function enable_ssl () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_ENABLE_SSL}" && -n "${OPT_HOST}" ]]; then
    send_yaml_filter ".ssl.enabled = true"
  fi
}

function disable_ssl () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_DISABLE_SSL}" && -n "${OPT_HOST}" ]]; then
    send_yaml_filter ".ssl.enabled = false"
  fi
}

function set_ssl_domain () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_DOMAIN_NAME}" && -n "${OPT_HOST}" ]]; then
    send_yaml_filter ".ssl.domain = \\\"${OPT_DOMAIN_NAME}\\\""
  fi
}

function send_filter () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_NAME}" ]]; then
    if [[ -n "${OPT_YAML_FILTER}" ]]; then
      send_yaml_filter
    fi

    if [[ -n "${OPT_ENABLE_SSL}" ]]; then
      enable_ssl
    fi

    if [[ -n "${OPT_DISABLE_SSL}" ]];then
      disable_ssl
    fi

    if [[ -n "${OPT_DOMAIN_NAME}" ]]; then
      set_ssl_domain
    fi
  fi

  exit $?
}

function connect_ssh () {
  debug ${FUNCNAME[0]} "$@"

  local address=$(get_droplet_address "${OPT_HOST}")

  if [[ -n "${address}" ]]; then
    run_ssh "${OPT_DROPLET_USER}@${address}"
  fi

  exit $?
}

function connect_sql () {
  debug ${FUNCNAME[0]} "$@"

  local address=$(get_droplet_address "${OPT_HOST}")

  if [[ -n "${address}" ]]; then
    run_ssh "${OPT_DROPLET_USER}@${address}" "/usr/local/bin/pgsql"
  fi

  exit $?
}

function send_command () {
  debug ${FUNCNAME[0]} "$@"

  for address in $(get_droplet_address "${OPT_HOST}"); do
    run_ssh "${OPT_DROPLET_USER}@${address}" "${OPT_COMMAND}"
  done

  exit $?
}

function expunge_instance () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_EXPUNGE_INSTANCE}" ]]; then
    doadm -XDN "${OPT_HOST}"
  fi

  exit $?
}

function list_instances () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_LIST_INSTANCES}" ]]; then
    doadm -lD | awk "/[0-9]+\s+miki/" | column -t
  fi

  exit 0
}

function generate_hash () {
  debug ${FUNCNAME[0]} "$@"

  echo "${1}" | htpasswd -niBC 10 "" | tr -d ':\n'
}

function upload_file () {
  debug ${FUNCNAME[0]} "$@"

  local address=$(get_droplet_address "${OPT_HOST}")
  local local_file="${1}"
  local remote_file="${2}"

  run_scp -q "${local_file}" "${OPT_DROPLET_USER}@${address}:${remote_file}"
}

function load_remote_sql () {
  debug ${FUNCNAME[0]} "$@"

  local address=$(get_droplet_address "${OPT_HOST}")
  local file="${1}"

  if [[ -n "${address}" ]]; then
    run_ssh "${OPT_DROPLET_USER}@${address}" "/usr/local/bin/pgsql -f ${file}; rm -f ${file}"
  fi
}

function generate_admin_password () {
  debug ${FUNCNAME[0]} "$@"

  VAL_ADMIN_PASSWORD="$(goxkcdpwgen -n 2)"
  VAL_ADMIN_PASSWORD_HASH=$(generate_hash "${VAL_ADMIN_PASSWORD}")
}

function create_admin_sql_file () {
  debug ${FUNCNAME[0]} "$@"

  local name=Administrator

  VAL_ADMIN_SQL_LOCAL_FILE=$(mktemp --suffix .sql)

  cat << EOF > ${VAL_ADMIN_SQL_LOCAL_FILE}
UPDATE users SET password = '${VAL_ADMIN_PASSWORD_HASH}' WHERE name = '${name}';
UPDATE users SET "mustChangePwd" = 't' WHERE name = '${name}';
EOF
}

function upload_admin_sql_file () {
  debug ${FUNCNAME[0]} "$@"

  VAL_ADMIN_SQL_REMOTE_FILE=$(mktemp --dry-run --suffix .sql)

  upload_file "${VAL_ADMIN_SQL_LOCAL_FILE}" "${VAL_ADMIN_SQL_REMOTE_FILE}"
  rm -f "${VAL_ADMIN_SQL_LOCAL_FILE}"
}

function remote_reset_admin_password () {
  debug ${FUNCNAME[0]} "$@"

  load_remote_sql "${VAL_ADMIN_SQL_REMOTE_FILE}"
}

function display_admin_password () {
  debug ${FUNCNAME[0]} "$@"

  echo "${VAL_ADMIN_PASSWORD}"
}

function reset_admin_password () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_RESET_ADMIN_PASSWORD}" && -n "${OPT_HOST}" ]]; then
    generate_admin_password
    create_admin_sql_file
    upload_admin_sql_file
    remote_reset_admin_password
    display_admin_password
  fi

  exit 0
}

function generate_support_password () {
  debug ${FUNCNAME[0]} "$@"

  VAL_SUPPORT_PASSWORD="$(goxkcdpwgen -n 2)"
  VAL_SUPPORT_PASSWORD_HASH=$(generate_hash "${VAL_SUPPORT_PASSWORD}")
}

function create_support_sql_file () {
  debug ${FUNCNAME[0]} "$@"

  VAL_SUPPORT_SQL_LOCAL_FILE=$(mktemp --suffix .sql)

  cat << EOF > ${VAL_SUPPORT_SQL_LOCAL_FILE}
INSERT INTO users VALUES('100', 'support@mimix.io','Miki Support', '', '${VAL_SUPPORT_PASSWORD_HASH}', 'f', '', '', '', '', 'America/New_York', 'f', 't', 't', 'f', '2020-01-01T00:00:00.00Z', '2020-11-13T11:19:07.084Z', 'local', 'en', 'markdown', '2020-11-13T11:19:49.393Z', '');
INSERT INTO "userGroups" VALUES('100', '100', '1');
EOF
}

function upload_support_sql_file () {
  debug ${FUNCNAME[0]} "$@"

  VAL_SUPPORT_SQL_REMOTE_FILE=$(mktemp --dry-run --suffix .sql)

  upload_file "${VAL_SUPPORT_SQL_LOCAL_FILE}" "${VAL_SUPPORT_SQL_REMOTE_FILE}"
  rm -f "${VAL_SUPPORT_SQL_LOCAL_FILE}"
}

function remote_create_support_account () {
  debug ${FUNCNAME[0]} "$@"

  load_remote_sql "${VAL_SUPPORT_SQL_REMOTE_FILE}"
}

function display_support_password () {
  debug ${FUNCNAME[0]} "$@"

  echo "${VAL_SUPPORT_PASSWORD}"
}

function create_support_account () {
  debug ${FUNCNAME[0]} "$@"

  if [[ -n "${OPT_CREATE_SUPPORT_ACCOUNT}" ]]; then
    generate_support_password
    create_support_sql_file
    upload_support_sql_file
    remote_create_support_account
    display_support_password
  fi

  exit 0
}

function remote_load_sql_file () {
  debug ${FUNCNAME[0]} "$@"

  local remote_file=$(mktemp --dry-run --suffix .sql)

  if [[ -n "${OPT_SQL_FILE}" && -f "${OPT_SQL_FILE}" && -n "${OPT_HOST}" ]]; then
    upload_file "${OPT_SQL_FILE}" "${remote_file}"
    load_remote_sql "${remote_file}"
  fi

  exit 0
}

function power_on_droplet () {
  debug ${FUNCNAME[0]} "$@"

  local id=$(get_droplet_id "${OPT_HOST}")

  doctl compute droplet-action power-on "${id}"

  exit $?
}

function power_off_droplet () {
  debug ${FUNCNAME[0]} "$@"

  local id=$(get_droplet_id "${OPT_HOST}")

  doctl compute droplet-action power-off "${id}"

  exit $?
}

function import_dump () {
  debug ${FUNCNAME[0]} "$@"

  local address=$(get_droplet_address "${OPT_HOST}")
  local remote_file=$(mktemp --dry-run --suffix .pg)

  run_scp "${OPT_IMPORT_DUMP}" "${OPT_DROPLET_USER}@${address}:${remote_file}"
  run_ssh "${OPT_DROPLET_USER}@${address}" "/usr/local/bin/pgadm -If ${remote_file}"

  exit 0
}

function export_dump () {
  debug ${FUNCNAME[0]} "$@"

  local address=$(get_droplet_address "${OPT_HOST}")
  local remote_file=$(mktemp --dry-run --suffix .pg)

  run_ssh "${OPT_DROPLET_USER}@${address}" "/usr/local/bin/pgadm -Ef ${remote_file}"
  run_scp "${OPT_DROPLET_USER}@${address}:${remote_file}" "${OPT_EXPORT_DUMP}"

  exit 0
}

function restart_miki () {
  debug ${FUNCNAME[0]} "$@"

  local address=$(get_droplet_address "${OPT_HOST}")

  run_ssh "${OPT_DROPLET_USER}@${address}" "systemctl restart miki.service"
}

function restart_machine () {
  debug ${FUNCNAME[0]} "$@"

  local address=$(get_droplet_address "${OPT_HOST}")

  run_ssh "${OPT_DROPLET_USER}@${address}" "reboot"
}

function main () {
  debug ${FUNCNAME[0]} "$@"

  parse_arguments "$@"
  set_names
  process_arguments "$@"

  local_install
  remote_install
}

main "$@"
